-----------------------------------------------------------------------------------
-- Copyright (c) 2006, 2007 IBM Corporation and others.
-- All rights reserved. This program and the accompanying materials
-- are made available under the terms of the Eclipse Public License v1.0
-- which accompanies this distribution, and is available at
-- http://www.eclipse.org/legal/epl-v10.html
--
-- Contributors:
--     IBM Corporation - initial API and implementation
-----------------------------------------------------------------------------------

-----------------------------------------------------------------------------------
-- Lexer for C99
--
-- Does not use a separate keyword lexer.
-----------------------------------------------------------------------------------

%Options la=2
%options package=org.eclipse.cdt.internal.core.dom.parser.c99
%options template=LexerTemplateD.g
%options export_terminals=("C99LexerBaseexp.java", "TK_")
%options verbose
%Options list
%options single_productions

$Notice
/./*******************************************************************************
 * Copyright (c) 2006, 2007 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/
 
  // This file was generated by LPG
./
$End

$Export
	auto
	break
	case
	char
	const
	continue
	default
	do
	double
	else
	enum
	extern
	float
	for
	goto
	if
	inline
	int
	long
	register
	restrict
	return
	short
	signed
	sizeof
	static
	struct
	switch
	typedef
	union
	unsigned
	void
	volatile
	while
	_Bool
	_Complex
	_Imaginary
	identifier
	integer
	floating
	charconst
	stringlit
	
	RightBracket
	LeftBracket
	RightParen
	LeftParen
	RightBrace
	LeftBrace
	Dot
	Arrow
	PlusPlus
	MinusMinus
	And
	Star
	Plus
	Minus
	Tilde
	Bang
	Slash
	Percent
	RightShift
	LeftShift
	LT
	GT
	LE
	GE
	EQ
	NE
	Caret
	Or
	AndAnd
	OrOr
	Question
	Colon
	SemiColon
	DotDotDot
	Assign
	StarAssign
	SlashAssign
	PercentAssign
	PlusAssign
	MinusAssign
	RightShiftAssign
	LeftShiftAssign
	AndAssign
	CaretAssign
	OrAssign
	Comma
	Hash
	HashHash
	NewLine
	
	-- Invalid tokens are the result of:
	--  1) a syntax error at the token level (created in the reportError() method)
	--  2) improper use of the ## operator, caught by the preprocessor
	Invalid
	
	
	-- Temporarily used during macro preprocessing (to support the ## operator)
	PlaceMarker
	-- Used to identify macro parameters within the body of 
	-- a macro for the purpose of avoiding name capture.
	Parameter 
	
	-- temporarily used during preprocessing
	-- prevents a recursive macro from repeated expansion 
	DisabledMacroName  
$End

$Globals
/.
	import java.util.*;
	import java.lang.*;
	import org.eclipse.cdt.core.parser.CodeReader;
    import org.eclipse.cdt.internal.core.dom.parser.c99.preprocessor.TokenList;
    import org.eclipse.cdt.internal.core.dom.parser.c99.preprocessor.C99Token;
    import org.eclipse.cdt.core.dom.c99.ILexer;
./
$End

$Define
	$ba /.$BeginAction./
	$ea /.$EndAction./
	$additional_interfaces /. , ILexer ./
$End


$Headers
/.
	private TokenList tokenList = null;
       
    public $action_type(CodeReader reader) {
    	super(reader.buffer, new String(reader.filename));
    }
    
    // defined in interface ILexer
    public synchronized TokenList lex() {
		tokenList = new TokenList();
            
        lexParser.parseCharacters(null);  // Lex the input characters
        
        TokenList result = tokenList;
        tokenList = null;
        return result;
    }
    
    protected void makeToken(int kind) {
		int startOffset = getLeftSpan();
		int endOffset   = getRightSpan();
		
		//System.out.println("Token: " + C99Parsersym.orderedTerminalSymbols[token]);
		C99Token token = new C99Token(startOffset, endOffset, kind);
		token.setRepresentation(getInputChars(), startOffset, endOffset);
		tokenList.add(token);
	}
	
	public void reportError(int leftOffset, int rightOffset) {
		C99Token token = new C99Token(leftOffset, rightOffset, $_Invalid);
		token.setRepresentation(getInputChars(), leftOffset, rightOffset);
		tokenList.add(token);
	}
	
	public int getKind(int i) {
		int streamLength = getStreamLength();
		char c = (i >= streamLength ? '\uffff' : getCharValue(i));
		return C99LexerKind.getKind(c);
	}
	
./
$End

$Terminals
	a    b    c    d    e    f    g    h    i    j    k    l    m
    n    o    p    q    r    s    t    u    v    w    x    y    z
    
    A    B    C    D    E    F    G    H    I    J    K    L    M
    N    O    P    Q    R    S    T    U    V    W    X    Y    Z
	_

    0    1    2    3    4    5    6    7    8    9
    
    EOF Space Unused
    
    LF   CR   HT   FF
    
    LF           ::= NewLine
    CR           ::= Return
    HT           ::= HorizontalTab
    FF           ::= FormFeed
    
    Space        ::= ' '
    Dot          ::= '.'
    LessThan     ::= '<'
    GreaterThan  ::= '>'
    Plus         ::= '+'
    Minus        ::= '-'
    Slash        ::= '/'
    BackSlash    ::= '\'
    Star         ::= '*'
    LeftParen    ::= '('
    RightParen   ::= ')'
    Equal        ::= '='
    LeftBracket  ::= '['
    RightBracket ::= ']'
    LeftBrace    ::= '{'
    RightBrace   ::= '}'
    Ampersand    ::= '&'
    Tilde        ::= '~'
    Bang         ::= '!'
    Percent      ::= '%'
    Caret        ::= '^'
    Bar          ::= '|'
    Question     ::= '?'
    Colon        ::= ':'
    SemiColon    ::= ';'
    Comma        ::= ','
    Hash         ::= '#'
    SingleQuote  ::= "'"
    DoubleQuote  ::= '"'
    
$End


$Start
	Token
$End

-----------------------------------------------------------------------------------
-- Deviation From Spec
--
-- The below grammar is slightly more lenient than the C99 spec in the following
-- ways.
--
-- 1) There is no differentiation between octal and decimal integer constants.
--    Normally an octal constant starts with a 0 and only contains octal digits.
--    This grammar allows an "integer" constant to start with any number of zeros
--    and contain any decimal digit. Therefore constants like "09" are allowed. 
-----------------------------------------------------------------------------------

-----------------------------------------------------------------------------------
-- TODO List
--
-- 1) Characters that are allowed in string and character literals:
--        any member of the source character set except 
--        the single-quote ', backslash \, or new-line character
--
-- 2) Preprocessor Tokens (this and above involve detection of newlines)
--
-- 3) Trigraph sequences (in getKind() method probably)
-- 
-- 4) Comments!
-----------------------------------------------------------------------------------


$Rules

    -----------------------------------------------------------------------------------
	-- Tokens that the parser will see
	-----------------------------------------------------------------------------------
	
	Token ::= identifier 
	          /.$ba  makeToken($_identifier); /*makeKeywordOrIdentifierToken();*/  $ea./
	
	Token ::= integer-constant  
	          /.$ba  makeToken($_integer);   $ea./
	
	Token ::= floating-constant 
	          /.$ba  makeToken($_floating);  $ea./
	
	Token ::= character-constant 
	          /.$ba  makeToken($_charconst); $ea./
	
	Token ::= string-literal 
	          /.$ba  makeToken($_stringlit); $ea./
	          
	-----------------------------------------------------------------------------------
	-- Punctuation
	--
    -- [ ] ( ) { } . ->
	-- ++ -- & * + - ~ !
	-- / % << >> < > <= >= == != ^ | && ||
	-- ? : ; ...
	-- = *= /= %= += -= <<= >>= &= ^= |=
	-- , # ##
	-- <: :> <% %> %: %:%:
	-----------------------------------------------------------------------------------
	
	Token ::= '[' 				/.$ba  makeToken($_LeftBracket);       $ea./
	Token ::= ']'   			/.$ba  makeToken($_RightBracket);      $ea./
	Token ::=  '('  			/.$ba  makeToken($_LeftParen);         $ea./
	Token ::=  ')'  			/.$ba  makeToken($_RightParen);        $ea./
	Token ::=  '{'  			/.$ba  makeToken($_LeftBrace);         $ea./
	Token ::=  '}'  			/.$ba  makeToken($_RightBrace);        $ea./
	Token ::=  '.'  			/.$ba  makeToken($_Dot);               $ea./
	Token ::=  '-' '>'  		/.$ba  makeToken($_Arrow);             $ea./
	Token ::=  '+' '+'  		/.$ba  makeToken($_PlusPlus);          $ea./
	Token ::=  '-' '-'  		/.$ba  makeToken($_MinusMinus);        $ea./
	Token ::=  '&'  			/.$ba  makeToken($_And);               $ea./
	Token ::=  '*'  			/.$ba  makeToken($_Star);              $ea./
	Token ::=  '+'  			/.$ba  makeToken($_Plus);              $ea./
	Token ::=  '-'  			/.$ba  makeToken($_Minus);             $ea./
	Token ::=  '~'  			/.$ba  makeToken($_Tilde);             $ea./
	Token ::=  '!'  			/.$ba  makeToken($_Bang);              $ea./
	Token ::=  '/'  			/.$ba  makeToken($_Slash);             $ea./
	Token ::=  '%'  			/.$ba  makeToken($_Percent);           $ea./
	Token ::=  '<' '<'  		/.$ba  makeToken($_LeftShift);        $ea./
	Token ::=  '>' '>'  		/.$ba  makeToken($_RightShift);         $ea./
	Token ::=  '<'  			/.$ba  makeToken($_LT);                $ea./
	Token ::=  '>'  			/.$ba  makeToken($_GT);                $ea./
	Token ::=  '<' '=' 			/.$ba  makeToken($_LE);                $ea./
	Token ::=  '>' '=' 			/.$ba  makeToken($_GE);                $ea./
	Token ::=  '=' '='  		/.$ba  makeToken($_EQ);                $ea./
	Token ::=  '!' '='  		/.$ba  makeToken($_NE);                $ea./
	Token ::=  '^'  			/.$ba  makeToken($_Caret);             $ea./
	Token ::=  '|'  			/.$ba  makeToken($_Or);                $ea./
	Token ::=  '&' '&'  		/.$ba  makeToken($_AndAnd);            $ea./
	Token ::=  '|' '|'  		/.$ba  makeToken($_OrOr);              $ea./
	Token ::=  '?'  			/.$ba  makeToken($_Question);          $ea./
	Token ::=  ':'  			/.$ba  makeToken($_Colon);             $ea./
	Token ::=  ';' 				/.$ba  makeToken($_SemiColon);         $ea./
	Token ::=  '.' '.' '.'  	/.$ba  makeToken($_DotDotDot);         $ea./
	Token ::=  '='  			/.$ba  makeToken($_Assign);            $ea./
	Token ::=  '*' '='  		/.$ba  makeToken($_StarAssign);        $ea./
	Token ::=  '/' '='  		/.$ba  makeToken($_SlashAssign);       $ea./
	Token ::=  '%' '='  		/.$ba  makeToken($_PercentAssign);     $ea./
	Token ::=  '+' '='  		/.$ba  makeToken($_PlusAssign);        $ea./
	Token ::=  '-' '='  		/.$ba  makeToken($_MinusAssign);       $ea./
	Token ::=  '<' '<' '='  	/.$ba  makeToken($_LeftShiftAssign);   $ea./
	Token ::=  '>' '>' '='  	/.$ba  makeToken($_RightShiftAssign);  $ea./
	Token ::=  '&' '='  		/.$ba  makeToken($_AndAssign);         $ea./
	Token ::=  '^' '='  		/.$ba  makeToken($_CaretAssign);       $ea./
	Token ::=  '|' '='  		/.$ba  makeToken($_OrAssign);          $ea./
	Token ::=  ','  			/.$ba  makeToken($_Comma);             $ea./
	Token ::=  '#'  			/.$ba  makeToken($_Hash);              $ea./
	Token ::=  '#' '#'  		/.$ba  makeToken($_HashHash);          $ea./
	Token ::=  '<' ':' 			/.$ba  makeToken($_RightBracket);      $ea./
	Token ::=  ':' '>' 			/.$ba  makeToken($_LeftBracket);       $ea./
	Token ::=  '<' '%' 			/.$ba  makeToken($_RightBrace);        $ea./
	Token ::=  '%' '>' 			/.$ba  makeToken($_LeftBrace);         $ea./
	Token ::=  '%' ':' 			/.$ba  makeToken($_Hash);              $ea./
	Token ::=  '%' ':' '%' ':' 	/.$ba  makeToken($_HashHash);          $ea./


    
          
	-----------------------------------------------------------------------------------
  	-- Character Sets
  	--
  	-- ! " # % & ' ( ) * + , - . / : ; < = > ? [ \ ] ^ _ { | } ~
  	--
  	-----------------------------------------------------------------------------------
   	
  	letter ::= 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 
  	           'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 
  	           'w' | 'x' | 'y' | 'z' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 
  	           'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 
  	           'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z'
    		
    nondigit ::= letter | '_'
    
	digit       ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'  
	
	octal-digit ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' 
	
	hexadecimal-digit ::= digit |
	                      'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 
	                      'A' | 'B' | 'C' | 'D' | 'E' | 'F'
	                      
    -- does not include "'", '"', '\', '/', '*' or whitespece
	common-graphical-character ::= '!' | '#' | '%' | '&' | '(' | ')' |
                                   '+' | ',' | '-' | '.' | ':' | ';' |
                                   '<' | '=' | '>' | '?' | '[' | ']' |  
                                   '^' | '_' | '{' | '|' | '}' | '~'
	   
                            
    graphical-character ::= common-graphical-character | -- still does not include whitespace
                            "'" | '"' | '\' | '/' | '*'  -- these are the special chars 
                            
    string-literal-char ::= digit | letter | common-graphical-character | Unused |
                            "'" | '/' | '*' | HT | FF | ' '  
    
    
    character-literal-char ::= digit | letter | common-graphical-character | Unused |
                               '"' | '/' | '*' | HT | FF | ' '  
    
    -- newlines are significant to the preprocessor
    ws-char ::= ' ' | CR | HT | FF 
    
    not-eol ::= digit | letter | Unused |                  -- not end of line
                graphical-character | HT | FF | ' '
    
    not-slash-or-star ::= digit | letter | common-graphical-character | ws-char | Unused |
                          "'" | '"' | '\' | LF -- not these: '/', '*'
    
 
    -----------------------------------------------------------------------------------
    -- Comments and whitespace
    -----------------------------------------------------------------------------------

    -- newlines are significant to the preprocessor, but are ignored if preceded by a backslash
	Token ::= NewLine          
	            /.$ba  makeToken($_NewLine); $ea./
	            
	Token ::= '\' WS NewLine 
    Token ::= '\' NewLine
    
    Token ::= WS
    Token ::= SLC
    Token ::= MLC
    
    
    WS -> ws-char
	    | WS ws-char
	     
	SLC -> '/' '/'
         |  SLC not-eol
         
    MLC ::= '/' '*' inside-mlc stars '/'
    
    stars -> '*'
           | stars '*' 
    
    inside-mlc -> inside-mlc stars not-slash-or-star
                | inside-mlc '/'
                | inside-mlc not-slash-or-star
                | stars not-slash-or-star
                | '/'
                | not-slash-or-star
                
                
  	-----------------------------------------------------------------------------------
  	-- Identifiers
  	-----------------------------------------------------------------------------------

	identifier ::= identifier-nondigit
				 | identifier identifier-nondigit
				 | identifier digit

	identifier-nondigit ::= nondigit 
	                      | universal-character-name
	                   -- other implementation defined characters

	-----------------------------------------------------------------------------------
  	-- Universal character names
  	-----------------------------------------------------------------------------------
	
	universal-character-name ::= '\' 'u' hex-quad 
	                           | '\' 'U' hex-quad hex-quad

	hex-quad ::= hexadecimal-digit 
	             hexadecimal-digit 
	             hexadecimal-digit 
	             hexadecimal-digit
	
	
	-----------------------------------------------------------------------------------
  	-- Constants
  	-----------------------------------------------------------------------------------

	
	
	-- Token ::= enumeration-constant
	
	 
	-- more lenient than spec grammar, no special rules for octal
	integer-constant ::= decimal-octal-constant
					   | decimal-octal-constant integer-suffix
					   | hexadecimal-constant
					   | hexadecimal-constant integer-suffix
	
	
	-- both decimal and octal constants are covered by one rule
	decimal-octal-constant ::= digit-sequence 
		
	-- slight deviation from spec grammar	
	hexadecimal-constant ::= hexadecimal-prefix hexadecimal-digit-sequence

    hexadecimal-prefix ::= '0' 'x' | '0' 'X'
    
    
	                   
	integer-suffix ::= unsigned-suffix
	                 | unsigned-suffix long-suffix
                     | unsigned-suffix long-long-suffix
                     | long-suffix
                     | long-suffix unsigned-suffix
                     | long-long-suffix
                     | long-long-suffix unsigned-suffix

	unsigned-suffix ::= 'u' | 'U'
	
	long-suffix ::= 'l' | 'L'

	long-long-suffix ::= 'l' 'l' | 'L' 'L'

	floating-constant ::= decimal-floating-constant
					    | hexadecimal-floating-constant

	decimal-floating-constant 
	   ::= fractional-constant
		 | fractional-constant exponent-part 
		 | fractional-constant exponent-part floating-suffix
		 | fractional-constant floating-suffix
		 | digit-sequence exponent-part    
		 | digit-sequence exponent-part floating-suffix
		 
		 
	hexadecimal-floating-constant 
	    ::= hexadecimal-prefix hexadecimal-fractional-constant binary-exponent-part
		  | hexadecimal-prefix hexadecimal-fractional-constant binary-exponent-part floating-suffix
		  | hexadecimal-prefix hexadecimal-digit-sequence binary-exponent-part
		  | hexadecimal-prefix hexadecimal-digit-sequence binary-exponent-part floating-suffix

	digit-sequence -> digit | digit-sequence digit
	
	fractional-constant ::= '.' digit-sequence
						  | digit-sequence '.'
						  | digit-sequence '.' digit-sequence

	exponent-part ::= 'e' sign digit-sequence
				    | 'e' digit-sequence
				    | 'E' sign digit-sequence
				    | 'E' digit-sequence
 
	sign ::= '+' | '-'

	hexadecimal-fractional-constant
		::= '.' hexadecimal-digit-sequence
		  | hexadecimal-digit-sequence '.'
		  | hexadecimal-digit-sequence '.' hexadecimal-digit-sequence

	binary-exponent-part ::= 'p' sign digit-sequence
	                       | 'p' digit-sequence
    					   | 'P' sign digit-sequence
						   | 'P' digit-sequence

	hexadecimal-digit-sequence ::= hexadecimal-digit
                                 | hexadecimal-digit-sequence hexadecimal-digit

	floating-suffix ::= 'f' | 'l' | 'F' | 'L'
	    
	    
	-----------------------------------------------------------------------------------
  	-- Enumeration Constants
  	-----------------------------------------------------------------------------------
	
	-- returned as identifier tokens
	-- enumeration-constant ::= identifier

    -----------------------------------------------------------------------------------
  	-- Character Constants
  	-----------------------------------------------------------------------------------
  	
    character-constant ::= "'" c-char-sequence "'"
                         | 'L' "'" c-char-sequence "'"	

    c-char-sequence ::= c-char
                      | c-char-sequence c-char
                      
    c-char ::= escape-sequence
             | character-literal-char

    escape-sequence ::= simple-escape-sequence
                      | octal-escape-sequence
                      | hexadecimal-escape-sequence
                      | universal-character-name
                      
    simple-escape-sequence ::= 
        '\' "'" | '\' '"' | '\' '?' | '\' '\' | '\' 'a' |
        '\' 'b' | '\' 'f' | '\' 'n' | '\' 'r' | '\' 't' | '\' 'v'


    octal-escape-sequence ::= '\' octal-digit
                            --| '\' octal-digit octal-digit
                           -- | '\' octal-digit octal-digit octal-digit
                            
    hexadecimal-escape-sequence ::= '\' 'x' hexadecimal-digit
                                  --| hexadecimal-escape-sequence hexadecimal-digit


    
    -----------------------------------------------------------------------------------
  	-- String Literals
  	-----------------------------------------------------------------------------------
  	
    string-literal ::= '"' '"'
                     | '"' s-char-sequence '"'
                     | 'L' '"' '"'
                     | 'L' '"' s-char-sequence '"'
    
    s-char-sequence ::= s-char
                      | s-char-sequence s-char
                      
    s-char ::= escape-sequence
             | string-literal-char
    
	
		
$End