/*******************************************************************************
* Copyright (c) 2006, 2007 IBM Corporation and others.
* All rights reserved. This program and the accompanying materials
* are made available under the terms of the Eclipse Public License v1.0
* which accompanies this distribution, and is available at
* http://www.eclipse.org/legal/epl-v10.html
*
* Contributors:
*     IBM Corporation - initial API and implementation
*******************************************************************************/

// This file was generated by LPG

package org.eclipse.cdt.internal.core.dom.parser.c99;

import lpg.lpgjavaruntime.*;

import java.util.*;
import java.lang.*;

public class C99Lexer extends LpgLexStream implements C99Parsersym, C99Lexersym, RuleAction
{
    private static ParseTable prs = new C99Lexerprs();
    private PrsStream prsStream;
    private LexParser lexParser = new LexParser(this, prs, this);

    public PrsStream getPrsStream() { return prsStream; }
    public int getToken(int i) { return lexParser.getToken(i); }
    public int getRhsFirstTokenIndex(int i) { return lexParser.getFirstToken(i); }
    public int getRhsLastTokenIndex(int i) { return lexParser.getLastToken(i); }

    public int getLeftSpan() { return lexParser.getFirstToken(); }
    public int getRightSpan() { return lexParser.getLastToken(); }

    public C99Lexer(String filename, int tab) throws java.io.IOException 
    {
        super(filename, tab);
    }

    public C99Lexer(char[] input_chars, String filename, int tab)
    {
        super(input_chars, filename, tab);
    }

    public C99Lexer(char[] input_chars, String filename)
    {
        this(input_chars, filename, 1);
    }

    public C99Lexer() {}

    public String[] orderedExportedSymbols() { return C99Parsersym.orderedTerminalSymbols; }
    public LexStream getLexStream() { return (LexStream) this; }

    public void lexer(PrsStream prsStream)
    {
        lexer(null, prsStream);
    }
    
    public void lexer(Monitor monitor, PrsStream prsStream)
    {
        if (getInputChars() == null)
            throw new NullPointerException("LexStream was not initialized");

        this.prsStream = prsStream;

        prsStream.makeToken(0, 0, 0); // Token list must start with a bad token
            
        lexParser.parseCharacters(monitor);  // Lex the input characters
            
        int i = getStreamIndex();
        prsStream.makeToken(i, i, TK_EOF_TOKEN); // and end with the end of file token
        prsStream.setStreamLength(prsStream.getSize());
            
        return;
    }

private C99LexerAction action = new C99LexerAction(this);

public int getKind(int kind) { return action.getKind(kind); }

    public void ruleAction( int ruleNumber)
    {
        switch(ruleNumber)
        {
 
            //
            // Rule 1:  Token ::= identifier
            //
            case 1: {  action.   makeKeywordOrIdentifierToken();            break;
            }
 
            //
            // Rule 2:  Token ::= integer-constant
            //
            case 2: {  action.   makeToken(TK_integer);             break;
            }
 
            //
            // Rule 3:  Token ::= floating-constant
            //
            case 3: {  action.   makeToken(TK_floating);            break;
            }
 
            //
            // Rule 4:  Token ::= character-constant
            //
            case 4: {  action.   makeToken(TK_charconst);           break;
            }
 
            //
            // Rule 5:  Token ::= string-literal
            //
            case 5: {  action.   makeToken(TK_stringlit);           break;
            }
 
            //
            // Rule 6:  Token ::= [
            //
            case 6: {  action.   makeToken(TK_LeftBracket);                 break;
            }
 
            //
            // Rule 7:  Token ::= ]
            //
            case 7: {  action.   makeToken(TK_RightBracket);                break;
            }
 
            //
            // Rule 8:  Token ::= (
            //
            case 8: {  action.   makeToken(TK_LeftParen);                   break;
            }
 
            //
            // Rule 9:  Token ::= )
            //
            case 9: {  action.   makeToken(TK_RightParen);                  break;
            }
 
            //
            // Rule 10:  Token ::= {
            //
            case 10: {  action.   makeToken(TK_LeftBrace);                   break;
            }
 
            //
            // Rule 11:  Token ::= }
            //
            case 11: {  action.   makeToken(TK_RightBrace);                  break;
            }
 
            //
            // Rule 12:  Token ::= .
            //
            case 12: {  action.   makeToken(TK_Dot);                         break;
            }
 
            //
            // Rule 13:  Token ::= - >
            //
            case 13: {  action.   makeToken(TK_Arrow);                       break;
            }
 
            //
            // Rule 14:  Token ::= + +
            //
            case 14: {  action.   makeToken(TK_PlusPlus);                    break;
            }
 
            //
            // Rule 15:  Token ::= - -
            //
            case 15: {  action.   makeToken(TK_MinusMinus);                  break;
            }
 
            //
            // Rule 16:  Token ::= &
            //
            case 16: {  action.   makeToken(TK_And);                         break;
            }
 
            //
            // Rule 17:  Token ::= *
            //
            case 17: {  action.   makeToken(TK_Star);                        break;
            }
 
            //
            // Rule 18:  Token ::= +
            //
            case 18: {  action.   makeToken(TK_Plus);                        break;
            }
 
            //
            // Rule 19:  Token ::= -
            //
            case 19: {  action.   makeToken(TK_Minus);                       break;
            }
 
            //
            // Rule 20:  Token ::= ~
            //
            case 20: {  action.   makeToken(TK_Tilde);                       break;
            }
 
            //
            // Rule 21:  Token ::= !
            //
            case 21: {  action.   makeToken(TK_Bang);                        break;
            }
 
            //
            // Rule 22:  Token ::= /
            //
            case 22: {  action.   makeToken(TK_Slash);                       break;
            }
 
            //
            // Rule 23:  Token ::= %
            //
            case 23: {  action.   makeToken(TK_Percent);                     break;
            }
 
            //
            // Rule 24:  Token ::= < <
            //
            case 24: {  action.   makeToken(TK_LeftShift);                  break;
            }
 
            //
            // Rule 25:  Token ::= > >
            //
            case 25: {  action.   makeToken(TK_RightShift);                   break;
            }
 
            //
            // Rule 26:  Token ::= <
            //
            case 26: {  action.   makeToken(TK_LT);                          break;
            }
 
            //
            // Rule 27:  Token ::= >
            //
            case 27: {  action.   makeToken(TK_GT);                          break;
            }
 
            //
            // Rule 28:  Token ::= < =
            //
            case 28: {  action.   makeToken(TK_LE);                          break;
            }
 
            //
            // Rule 29:  Token ::= > =
            //
            case 29: {  action.   makeToken(TK_GE);                          break;
            }
 
            //
            // Rule 30:  Token ::= = =
            //
            case 30: {  action.   makeToken(TK_EQ);                          break;
            }
 
            //
            // Rule 31:  Token ::= ! =
            //
            case 31: {  action.   makeToken(TK_NE);                          break;
            }
 
            //
            // Rule 32:  Token ::= ^
            //
            case 32: {  action.   makeToken(TK_Caret);                       break;
            }
 
            //
            // Rule 33:  Token ::= |
            //
            case 33: {  action.   makeToken(TK_Or);                          break;
            }
 
            //
            // Rule 34:  Token ::= & &
            //
            case 34: {  action.   makeToken(TK_AndAnd);                      break;
            }
 
            //
            // Rule 35:  Token ::= | |
            //
            case 35: {  action.   makeToken(TK_OrOr);                        break;
            }
 
            //
            // Rule 36:  Token ::= ?
            //
            case 36: {  action.   makeToken(TK_Question);                    break;
            }
 
            //
            // Rule 37:  Token ::= :
            //
            case 37: {  action.   makeToken(TK_Colon);                       break;
            }
 
            //
            // Rule 38:  Token ::= ;
            //
            case 38: {  action.   makeToken(TK_SemiColon);                   break;
            }
 
            //
            // Rule 39:  Token ::= . . .
            //
            case 39: {  action.   makeToken(TK_DotDotDot);                   break;
            }
 
            //
            // Rule 40:  Token ::= =
            //
            case 40: {  action.   makeToken(TK_Assign);                      break;
            }
 
            //
            // Rule 41:  Token ::= * =
            //
            case 41: {  action.   makeToken(TK_StarAssign);                  break;
            }
 
            //
            // Rule 42:  Token ::= / =
            //
            case 42: {  action.   makeToken(TK_SlashAssign);                 break;
            }
 
            //
            // Rule 43:  Token ::= % =
            //
            case 43: {  action.   makeToken(TK_PercentAssign);               break;
            }
 
            //
            // Rule 44:  Token ::= + =
            //
            case 44: {  action.   makeToken(TK_PlusAssign);                  break;
            }
 
            //
            // Rule 45:  Token ::= - =
            //
            case 45: {  action.   makeToken(TK_MinusAssign);                 break;
            }
 
            //
            // Rule 46:  Token ::= < < =
            //
            case 46: {  action.   makeToken(TK_LeftShiftAssign);             break;
            }
 
            //
            // Rule 47:  Token ::= > > =
            //
            case 47: {  action.   makeToken(TK_RightShiftAssign);            break;
            }
 
            //
            // Rule 48:  Token ::= & =
            //
            case 48: {  action.   makeToken(TK_AndAssign);                   break;
            }
 
            //
            // Rule 49:  Token ::= ^ =
            //
            case 49: {  action.   makeToken(TK_CaretAssign);                 break;
            }
 
            //
            // Rule 50:  Token ::= | =
            //
            case 50: {  action.   makeToken(TK_OrAssign);                    break;
            }
 
            //
            // Rule 51:  Token ::= ,
            //
            case 51: {  action.   makeToken(TK_Comma);                       break;
            }
 
            //
            // Rule 52:  Token ::= #
            //
            case 52: {  action.   makeToken(TK_Hash);                        break;
            }
 
            //
            // Rule 53:  Token ::= # #
            //
            case 53: {  action.   makeToken(TK_HashHash);                    break;
            }
 
            //
            // Rule 54:  Token ::= < :
            //
            case 54: {  action.   makeToken(TK_RightBracket);                break;
            }
 
            //
            // Rule 55:  Token ::= : >
            //
            case 55: {  action.   makeToken(TK_LeftBracket);                 break;
            }
 
            //
            // Rule 56:  Token ::= < %
            //
            case 56: {  action.   makeToken(TK_RightBrace);                  break;
            }
 
            //
            // Rule 57:  Token ::= % >
            //
            case 57: {  action.   makeToken(TK_LeftBrace);                   break;
            }
 
            //
            // Rule 58:  Token ::= % :
            //
            case 58: {  action.   makeToken(TK_Hash);                        break;
            }
 
            //
            // Rule 59:  Token ::= % : % :
            //
            case 59: {  action.   makeToken(TK_HashHash);                    break;
            }

    
            default:
                break;
        }
        return;
    }
}

