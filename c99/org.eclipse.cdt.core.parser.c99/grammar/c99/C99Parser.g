-----------------------------------------------------------------------------------
-- Copyright (c) 2006, 2007 IBM Corporation and others.
-- All rights reserved. This program and the accompanying materials
-- are made available under the terms of the Eclipse Public License v1.0
-- which accompanies this distribution, and is available at
-- http://www.eclipse.org/legal/epl-v10.html
--
-- Contributors:
--     IBM Corporation - initial API and implementation
-----------------------------------------------------------------------------------



-----------------------------------------------------------------------------------
-- Big TODO List
--
-- Preprocessor
-- Re-refactor statment rules to be simpler, 
--     its okay to have a shift/reduce conflict for dangling else.
-- Simplify grammar by using more *_opt rules
-- 
-----------------------------------------------------------------------------------


%options la=2
%options package=org.eclipse.cdt.internal.core.dom.parser.c99
%options template=btParserTemplateD.g
%options import_terminals=C99Lexer.g


$Notice
/./*******************************************************************************
 * Copyright (c) 2006, 2007 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *********************************************************************************/
 
 // This file was generated by LPG
./
$End

$Terminals

-- These are just aliases for lexer tokens

-- RightBracket ::= ']'
LeftBracket  ::= '['
-- RightParen   ::= ')'
LeftParen    ::= '('
-- RightBrace   ::= '}'
LeftBrace    ::= '{'
Dot          ::= '.'
Arrow        ::= '->'
PlusPlus     ::= '++'
MinusMinus   ::= '--'
And          ::= '&'
Star         ::= '*'
Plus         ::= '+'
Minus        ::= '-'
Tilde        ::= '~'
Bang         ::= '!'
Slash        ::= '/'
Percent      ::= '%'
RightShift   ::= '>>'
LeftShift    ::= '<<'
LT           ::= '<'
GT           ::= '>'
LE           ::= '<='
GE           ::= '>='
EQ           ::= '=='
NE           ::= '!='
Caret        ::= '^'
Or           ::= '|'
AndAnd       ::= '&&'
OrOr         ::= '||'
Question     ::= '?'
Colon        ::= ':'
-- SemiColon    ::= ';'
DotDotDot    ::= '...'
Assign           ::= '='
StarAssign       ::= '*='
SlashAssign      ::= '/='
PercentAssign    ::= '%='
PlusAssign       ::= '+='
MinusAssign      ::= '-='
RightShiftAssign ::= '>>='
LeftShiftAssign  ::= '<<='
AndAssign        ::= '&='
CaretAssign      ::= '^='
OrAssign         ::= '|='
Comma            ::= ','
Hash             ::= '#'
HashHash         ::= '##'
NewLine          ::= 'nl'

$End


$Globals
/.	
	import java.util.*;
	
	import org.eclipse.cdt.core.dom.ast.*;
	import org.eclipse.cdt.core.dom.c99.IPreprocessorTokenOuput;
	import org.eclipse.cdt.internal.core.parser.scanner2.ILocationResolver;
	import org.eclipse.cdt.core.index.IIndex;
	import org.eclipse.cdt.core.dom.ast.IASTCompletionNode;
./
$End

$Define
	$ast_class /.Object./
	$ba /.$BeginAction action.beforeConsume(); action. ./
	$ea /.$EndAction./
	$additional_interfaces /. , IPreprocessorTokenOuput ./
$End


$Headers
/.
	private C99ParserAction action = new C99ParserAction(this);
	
	public C99Parser() {}
	
	public IASTTranslationUnit parse(ILocationResolver resolver, IIndex index) {
		action.setResolver(resolver);
		action.setIndex(index);
		parser(null, -1);
		return action.getAST();
	}

	public void prepareToParse() {
		// this has to be done, or... kaboom!
		setStreamLength(getSize());
	}
	
	public boolean encounteredError() {
		return action.encounteredError();
	}
	
	public IASTCompletionNode getASTCompletionNode() {
		return action.getASTCompletionNode();
	}
./
$End


$Start
	translation_unit
$End



$Rules

-------------------------------------------------------------------------------------------
-- AST Scoping
--
-- Special empty rule used to trigger the opening of a new AST scope
-------------------------------------------------------------------------------------------


<openscope> ::= $empty  /.$ba  openASTScope();  $ea./
           

-------------------------------------------------------------------------------------------
-- Content assist
--
-------------------------------------------------------------------------------------------


ident ::= 'identifier'
			--/.$ba  consumeName();  $ea./
        | 'Completion'
            --/.$ba  consumeCompletion();  $ea./


']' ::=? 'RightBracket'
       | 'EndOfCompletion'
      
')' ::=? 'RightParen'
       | 'EndOfCompletion'
      
'}' ::=? 'RightBrace'
       | 'EndOfCompletion'
      
';' ::=? 'SemiColon'
       | 'EndOfCompletion'


-------------------------------------------------------------------------------------------
-- Expressions
-------------------------------------------------------------------------------------------


constant
    ::= 'integer'                    
          /.$ba  consumeExpressionConstant(IASTLiteralExpression.lk_integer_constant);  $ea./
      | 'floating'                   
          /.$ba  consumeExpressionConstant(IASTLiteralExpression.lk_float_constant);    $ea./
      | 'charconst'                  
          /.$ba  consumeExpressionConstant(IASTLiteralExpression.lk_char_constant);     $ea./
      | 'stringlit'                  
          /.$ba  consumeExpressionConstant(IASTLiteralExpression.lk_string_literal);    $ea./

primary_expression 
    ::= constant 
      | ident                 
          /.$ba  consumeExpressionID();  $ea./
      | '(' expression ')'         
          /.$ba  consumeExpressionBracketed();  $ea./

postfix_expression
    ::= primary_expression
      | postfix_expression '[' expression ']'
          /.$ba  consumeExpressionArraySubscript();  $ea./
      | postfix_expression '(' ')'
          /.$ba  consumeExpressionFunctionCall(false);  $ea./
      | postfix_expression '(' argument_expression_list ')'
          /.$ba  consumeExpressionFunctionCall(true);  $ea./
      | postfix_expression '.' ident
          /.$ba  consumeExpressionFieldReference(false);  $ea./
      | postfix_expression '->' ident
          /.$ba  consumeExpressionFieldReference(true);  $ea./
      | postfix_expression '++'
          /.$ba  consumeExpressionUnaryOperator(IASTUnaryExpression.op_postFixIncr);  $ea./
      | postfix_expression '--'
          /.$ba  consumeExpressionUnaryOperator(IASTUnaryExpression.op_postFixDecr);  $ea./
      | '(' type_name ')' '{' <openscope> initializer_list '}'        
          /.$ba  consumeExpressionTypeIdInitializer();  $ea./
      | '(' type_name ')' '{' <openscope> initializer_list ',' '}'    
          /.$ba  consumeExpressionTypeIdInitializer();  $ea./ 



argument_expression_list
    ::= assignment_expression
         /.$ba  consumeExpressionArgumentExpressionList(true);  $ea./
      | argument_expression_list ',' assignment_expression
         /.$ba  consumeExpressionArgumentExpressionList(false); $ea./
      
unary_expression
    ::= postfix_expression
      | '++' unary_expression
          /.$ba  consumeExpressionUnaryOperator(IASTUnaryExpression.op_prefixIncr);  $ea./
      | '--' unary_expression
          /.$ba  consumeExpressionUnaryOperator(IASTUnaryExpression.op_prefixDecr);  $ea./
      | '&' cast_expression
          /.$ba  consumeExpressionUnaryOperator(IASTUnaryExpression.op_amper);  $ea./
      | '*' cast_expression
          /.$ba  consumeExpressionUnaryOperator(IASTUnaryExpression.op_star);   $ea./
      | '+' cast_expression
          /.$ba  consumeExpressionUnaryOperator(IASTUnaryExpression.op_plus);   $ea./
      | '-' cast_expression
          /.$ba  consumeExpressionUnaryOperator(IASTUnaryExpression.op_minus);  $ea./
      | '~' cast_expression
          /.$ba  consumeExpressionUnaryOperator(IASTUnaryExpression.op_tilde);  $ea./
      | '!' cast_expression
          /.$ba  consumeExpressionUnaryOperator(IASTUnaryExpression.op_not);    $ea./
      | 'sizeof' unary_expression
          /.$ba  consumeExpressionUnaryOperator(IASTUnaryExpression.op_sizeof); $ea./
      | 'sizeof' '(' type_name ')'
          /.$ba  consumeExpressionUnarySizeofTypeName();  $ea./  

cast_expression
    ::= unary_expression
      | '(' type_name ')' cast_expression
          /.$ba  consumeExpressionCast();  $ea./ 


multiplicative_expression
    ::= cast_expression
      | multiplicative_expression '*' cast_expression
          /.$ba  consumeExpressionBinaryOperator(IASTBinaryExpression.op_multiply); $ea./
      | multiplicative_expression '/' cast_expression
          /.$ba  consumeExpressionBinaryOperator(IASTBinaryExpression.op_divide);   $ea./
      | multiplicative_expression '%' cast_expression
          /.$ba  consumeExpressionBinaryOperator(IASTBinaryExpression.op_modulo);   $ea./

additive_expression
    ::= multiplicative_expression
      | additive_expression '+' multiplicative_expression
          /.$ba  consumeExpressionBinaryOperator(IASTBinaryExpression.op_plus);  $ea./
      | additive_expression '-' multiplicative_expression
          /.$ba  consumeExpressionBinaryOperator(IASTBinaryExpression.op_minus); $ea./

shift_expression
    ::= additive_expression
      | shift_expression '<<' additive_expression
          /.$ba  consumeExpressionBinaryOperator(IASTBinaryExpression.op_shiftLeft);   $ea./
      | shift_expression '>>' additive_expression
          /.$ba  consumeExpressionBinaryOperator(IASTBinaryExpression.op_shiftRight);  $ea./
      
relational_expression
    ::= shift_expression
      | relational_expression '<' shift_expression
          /.$ba  consumeExpressionBinaryOperator(IASTBinaryExpression.op_lessThan);     $ea./
      | relational_expression '>' shift_expression
          /.$ba  consumeExpressionBinaryOperator(IASTBinaryExpression.op_greaterThan);  $ea./
      | relational_expression '<=' shift_expression
          /.$ba  consumeExpressionBinaryOperator(IASTBinaryExpression.op_lessEqual);    $ea./
      | relational_expression '>=' shift_expression
          /.$ba  consumeExpressionBinaryOperator(IASTBinaryExpression.op_greaterEqual); $ea./

equality_expression
    ::= relational_expression
      | equality_expression '==' relational_expression
          /.$ba  consumeExpressionBinaryOperator(IASTBinaryExpression.op_equals);  $ea./
      | equality_expression '!=' relational_expression
          /.$ba  consumeExpressionBinaryOperator(IASTBinaryExpression.op_notequals);  $ea./

AND_expression
    ::= equality_expression
      | AND_expression '&' equality_expression
          /.$ba  consumeExpressionBinaryOperator(IASTBinaryExpression.op_binaryAnd);  $ea./

exclusive_OR_expression
    ::= AND_expression
      | exclusive_OR_expression '^' AND_expression
          /.$ba  consumeExpressionBinaryOperator(IASTBinaryExpression.op_binaryXor);  $ea./

inclusive_OR_expression
    ::= exclusive_OR_expression
      | inclusive_OR_expression '|' exclusive_OR_expression
          /.$ba  consumeExpressionBinaryOperator(IASTBinaryExpression.op_binaryOr);  $ea./

logical_AND_expression
    ::= inclusive_OR_expression
      | logical_AND_expression '&&' inclusive_OR_expression
          /.$ba  consumeExpressionBinaryOperator(IASTBinaryExpression.op_logicalAnd);  $ea./

logical_OR_expression
    ::= logical_AND_expression
      | logical_OR_expression '||' logical_AND_expression
          /.$ba  consumeExpressionBinaryOperator(IASTBinaryExpression.op_logicalOr);  $ea./

conditional_expression
    ::= logical_OR_expression
      | logical_OR_expression '?' expression ':' conditional_expression
          /.$ba  consumeExpressionConditional();  $ea./

assignment_expression
    ::= conditional_expression
      | unary_expression '='   assignment_expression
          /.$ba  consumeExpressionBinaryOperator(IASTBinaryExpression.op_assign);  $ea./
      | unary_expression '*='  assignment_expression
          /.$ba  consumeExpressionBinaryOperator(IASTBinaryExpression.op_multiplyAssign);  $ea./
      | unary_expression '/='  assignment_expression
          /.$ba  consumeExpressionBinaryOperator(IASTBinaryExpression.op_divideAssign);  $ea./
      | unary_expression '%='  assignment_expression
          /.$ba  consumeExpressionBinaryOperator(IASTBinaryExpression.op_moduloAssign);  $ea./
      | unary_expression '+='  assignment_expression
          /.$ba  consumeExpressionBinaryOperator(IASTBinaryExpression.op_plusAssign);  $ea./
      | unary_expression '-='  assignment_expression
          /.$ba  consumeExpressionBinaryOperator(IASTBinaryExpression.op_minusAssign);  $ea./
      | unary_expression '<<=' assignment_expression
          /.$ba  consumeExpressionBinaryOperator(IASTBinaryExpression.op_shiftLeftAssign);  $ea./
      | unary_expression '>>=' assignment_expression
          /.$ba  consumeExpressionBinaryOperator(IASTBinaryExpression.op_shiftRightAssign);  $ea./
      | unary_expression '&='  assignment_expression
          /.$ba  consumeExpressionBinaryOperator(IASTBinaryExpression.op_binaryAndAssign);  $ea./
      | unary_expression '^='  assignment_expression
          /.$ba  consumeExpressionBinaryOperator(IASTBinaryExpression.op_binaryXorAssign);  $ea./
      | unary_expression '|='  assignment_expression
          /.$ba  consumeExpressionBinaryOperator(IASTBinaryExpression.op_binaryOrAssign);  $ea./
      
	
-- special rule to avoid confict between problem statments and problem expressions
expression_in_statement
    ::= expression_list
        /.$ba  consumeExpression();  $ea./

expression
    ::= expression_list
        /.$ba  consumeExpression();  $ea./
      --| ERROR_TOKEN
      --   /.$ba  consumeExpressionProblem();  $ea./

expression_list
    ::= assignment_expression
         /.$ba  consumeExpressionList(true);  $ea./
      | expression_list ',' assignment_expression 
         /.$ba  consumeExpressionList(false);  $ea./

constant_expression
    ::= conditional_expression
      --| ERROR_TOKEN
      --   /.$ba  consumeExpressionProblem();  $ea./
      -- I think expressions will have to go at the bottom of the grammar for this to work
      

-------------------------------------------------------------------------------------------
-- Statements
-------------------------------------------------------------------------------------------
      
-- Grammar for if statements has been rewritten to avoid the "dangling else" ambiguity


statement
    ::= matched_statement
      | unmatched_statement
      | ERROR_TOKEN
          /.$ba  consumeStatementProblem();  $ea./
      
labeled_statement
    ::= label_identifier ':' unmatched_statement
         /.$ba  consumeStatementLabeled();  $ea./
      | 'case' constant_expression ':' unmatched_statement
         /.$ba  consumeStatementCase();  $ea./
      | 'default' ':' unmatched_statement
         /.$ba  consumeStatementDefault();  $ea./

labeled_statement_matched
    ::= label_identifier ':' matched_statement
         /.$ba  consumeStatementLabeled();  $ea./
      | 'case' constant_expression ':' matched_statement
         /.$ba  consumeStatementCase();  $ea./
      | 'default' ':' matched_statement
         /.$ba  consumeStatementDefault();  $ea./

label_identifier
    ::= 'identifier'
         /.$ba  consumeName();  $ea./

compound_statement
    ::= '{' '}' 
         /.$ba  consumeStatementEmptyCompoundStatement();  $ea./
      | <openscope> '{' block_item_list '}'
         /.$ba  consumeStatementCompoundStatement();  $ea./
        
block_item_list
    ::= block_item
      | block_item_list block_item


expression_statement
    ::= ';'
         /.$ba  consumeStatementNull();  $ea./  
      | expression_in_statement ';'
         /.$ba  consumeStatementExpression();  $ea./

         
block_item
    ::= statement
      | declaration
         /.$ba  consumeStatementDeclaration();  $ea./
            

switch_statement
    ::= 'switch' '(' expression ')' unmatched_statement
         /.$ba  consumeStatementSwitch();  $ea./
         
switch_statement_matched
    ::= 'switch' '(' expression ')' matched_statement
         /.$ba  consumeStatementSwitch();  $ea./


unmatched_statement
    ::= 'if' '(' expression ')' statement
         /.$ba  consumeStatementIfThen();  $ea./
      | 'if' '(' expression ')' matched_statement 'else' unmatched_statement
         /.$ba  consumeStatementIfThenElse();  $ea./ 
      | labeled_statement
      | switch_statement
      | iteration_statement
      

matched_statement
    ::= 'if' '(' expression ')' matched_statement 'else' matched_statement
         /.$ba  consumeStatementIfThenElse();  $ea./ 
      | labeled_statement_matched
      | switch_statement_matched
      | iteration_statement_matched
      | compound_statement
      | jump_statement
      | expression_statement
      
      
      
iteration_statement
    ::= 'while' '(' expression ')' unmatched_statement
          /.$ba  consumeStatementWhileLoop();  $ea./
      | 'for' '(' expression ';' expression ';' expression ')' unmatched_statement
          /.$ba  consumeStatementForLoop(true, true, true);  $ea./
      | 'for' '(' expression ';' expression ';'            ')' unmatched_statement
          /.$ba  consumeStatementForLoop(true, true, false);  $ea./
      | 'for' '(' expression ';'            ';' expression ')' unmatched_statement
          /.$ba  consumeStatementForLoop(true, false, true);  $ea./
      | 'for' '(' expression ';'            ';'            ')' unmatched_statement
          /.$ba  consumeStatementForLoop(true, false, false);  $ea./
      | 'for' '('            ';' expression ';' expression ')' unmatched_statement
          /.$ba  consumeStatementForLoop(false, true, true);  $ea./
      | 'for' '('            ';' expression ';'            ')' unmatched_statement
          /.$ba  consumeStatementForLoop(false, true, false);  $ea./
      | 'for' '('            ';'            ';' expression ')' unmatched_statement
          /.$ba  consumeStatementForLoop(false, false, true);  $ea./
      | 'for' '('            ';'            ';'            ')' unmatched_statement
          /.$ba  consumeStatementForLoop(false, false, false);  $ea./
      | 'for' '(' declaration expression ';' expression ')' unmatched_statement
          /.$ba  consumeStatementForLoop(true, true, true);  $ea./
      | 'for' '(' declaration expression ';'            ')' unmatched_statement
          /.$ba  consumeStatementForLoop(true, true, false);  $ea./
      | 'for' '(' declaration            ';' expression ')' unmatched_statement
          /.$ba  consumeStatementForLoop(true, false, true);  $ea./
      | 'for' '(' declaration            ';'            ')' unmatched_statement
          /.$ba  consumeStatementForLoop(true, false, false);  $ea./

iteration_statement_matched
    ::= 'do' statement 'while' '(' expression ')' ';'
          /.$ba  consumeStatementDoLoop();  $ea./
      | 'while' '(' expression ')' matched_statement
          /.$ba  consumeStatementWhileLoop();  $ea./
      | 'for' '(' expression ';' expression ';' expression ')' matched_statement
          /.$ba  consumeStatementForLoop(true, true, true);  $ea./
      | 'for' '(' expression ';' expression ';'            ')' matched_statement
          /.$ba  consumeStatementForLoop(true, true, false);  $ea./
      | 'for' '(' expression ';'            ';' expression ')' matched_statement
          /.$ba  consumeStatementForLoop(true, false, true);  $ea./
      | 'for' '(' expression ';'            ';'            ')' matched_statement
          /.$ba  consumeStatementForLoop(true, false, false);  $ea./
      | 'for' '('            ';' expression ';' expression ')' matched_statement
          /.$ba  consumeStatementForLoop(false, true, true);  $ea./
      | 'for' '('            ';' expression ';'            ')' matched_statement
          /.$ba  consumeStatementForLoop(false, true, false);  $ea./
      | 'for' '('            ';'            ';' expression ')' matched_statement
          /.$ba  consumeStatementForLoop(false, false, true);  $ea./
      | 'for' '('            ';'            ';'            ')' matched_statement
          /.$ba  consumeStatementForLoop(false, false, false);  $ea./
      | 'for' '(' declaration expression ';' expression ')' matched_statement
          /.$ba  consumeStatementForLoop(true, true, true);  $ea./
      | 'for' '(' declaration expression ';'            ')' matched_statement
          /.$ba  consumeStatementForLoop(true, true, false);  $ea./
      | 'for' '(' declaration            ';' expression ')' matched_statement
          /.$ba  consumeStatementForLoop(true, false, true);  $ea./
      | 'for' '(' declaration            ';'            ')' matched_statement
          /.$ba  consumeStatementForLoop(true, false, false);  $ea./
          
jump_statement
    ::= 'goto' 'identifier' ';'
          /.$ba  consumeStatementGoto();  $ea./
      | 'continue' ';'
          /.$ba  consumeStatementContinue();  $ea./
      | 'break' ';'
          /.$ba  consumeStatementBreak();  $ea./
      | 'return' ';'
          /.$ba  consumeStatementReturn(false);  $ea./
      | 'return' expression ';'
          /.$ba  consumeStatementReturn(true);  $ea./
          
          
-------------------------------------------------------------------------------------------
-- Declarations
-------------------------------------------------------------------------------------------

declaration 
    ::= declaration_specifiers  ';'
          /.$ba  consumeDeclaration(false);  $ea./
	  | declaration_specifiers <openscope> init_declarator_list ';'
	      /.$ba  consumeDeclaration(true);  $ea./
         

-- 4 declaration specifier rules
-- 1) simple, consists of just keywords, eg. unsigned long int
-- 2) enum
-- 3) struct or union
-- 4) typedef name
-- TODO refactor specifier_qualifier_list also

declaration_specifiers
    ::= <openscope> simple_declaration_specifiers
            /.$ba  consumeDeclarationSpecifiersSimple(); $ea./
      | <openscope> struct_or_union_declaration_specifiers
            /.$ba  consumeDeclarationSpecifiersStructUnionEnum(); $ea./
      | <openscope> enum_declaration_specifiers
            /.$ba  consumeDeclarationSpecifiersStructUnionEnum(); $ea./
      | <openscope> typdef_name_declaration_specifiers
            /.$ba  consumeDeclarationSpecifiersTypedefName(); $ea./

--simple_declaration_specifiers
--    ::= storage_class_specifier
--      | simple_declaration_specifiers storage_class_specifier
--      | type_specifier
--      | simple_declaration_specifiers type_specifier
--      | type_qualifier
--      | simple_declaration_specifiers type_qualifier 
--      | function_specifier
--      | simple_declaration_specifiers function_specifier 

-- like the simple case but without any type
no_type_declaration_specifiers
    ::= storage_class_specifier
      | no_type_declaration_specifiers storage_class_specifier
      | type_qualifier
      | no_type_declaration_specifiers type_qualifier 
      | function_specifier
      | no_type_declaration_specifiers function_specifier 

simple_declaration_specifiers
    ::= no_type_declaration_specifiers type_specifier simple_declaration_specifiers
      | type_specifier simple_declaration_specifiers
      | type_specifier
      | no_type_declaration_specifiers
      | no_type_declaration_specifiers type_specifier
      
struct_or_union_declaration_specifiers
    ::= no_type_declaration_specifiers  struct_or_union_specifier  no_type_declaration_specifiers
      | struct_or_union_specifier  no_type_declaration_specifiers
      | no_type_declaration_specifiers  struct_or_union_specifier
      | struct_or_union_specifier

enum_declaration_specifiers
    ::= no_type_declaration_specifiers  enum_specifier  no_type_declaration_specifiers
      | enum_specifier  no_type_declaration_specifiers
      | no_type_declaration_specifiers  enum_specifier
      | enum_specifier


typdef_name_declaration_specifiers
    ::= no_type_declaration_specifiers  typedef_name  no_type_declaration_specifiers
      | typedef_name  no_type_declaration_specifiers
      | no_type_declaration_specifiers  typedef_name
      | typedef_name
      
--no_type_declaration_specifiers_opt
--    ::= no_type_declaration_specifiers
--      | $empty

init_declarator_list
    ::= init_declarator
      | init_declarator_list ',' init_declarator
					  
init_declarator 
    ::= declarator
      | declarator '=' initializer
            /.$ba  consumeDeclaratorWithInitializer();  $ea./


-- at most one storage_class_specifier is allowed in the declaration specifiers
storage_class_specifier 
    ::= 'typedef'   /.$ba  consumeToken();  $ea./
      | 'extern'    /.$ba  consumeToken();  $ea./
      | 'static'    /.$ba  consumeToken();  $ea./
      | 'auto'      /.$ba  consumeToken();  $ea./
      | 'register'  /.$ba  consumeToken();  $ea./		

				
type_specifier
    ::= 'void'        /.$ba  consumeToken();  $ea./
      | 'char'        /.$ba  consumeToken();  $ea./
      | 'short'       /.$ba  consumeToken();  $ea./
      | 'int'         /.$ba  consumeToken();  $ea./
      | 'long'        /.$ba  consumeToken();  $ea./
      | 'float'       /.$ba  consumeToken();  $ea./
      | 'double'      /.$ba  consumeToken();  $ea./
      | 'signed'      /.$ba  consumeToken();  $ea./
      | 'unsigned'    /.$ba  consumeToken();  $ea./
      | '_Bool'       /.$ba  consumeToken();  $ea./
      | '_Complex'    /.$ba  consumeToken();  $ea./
      | '_Imaginary'  /.$ba  consumeToken();  $ea./
      
      -- separated out into their own rules
      --| typedef_name /.$ba  consumeToken();  $ea./
      --| struct_or_union_specifier
      --| enum_specifier
		
		
typedef_name
    ::= ident   /.$ba  consumeToken();  $ea./
    
    
struct_or_union_specifier
    ::= 'struct' '{' <openscope> struct_declaration_list_opt '}'
           /.$ba  consumeTypeSpecifierComposite(false, IASTCompositeTypeSpecifier.k_struct);  $ea./
           
      | 'union' '{' <openscope> struct_declaration_list_opt '}'
           /.$ba  consumeTypeSpecifierComposite(false, IASTCompositeTypeSpecifier.k_union);  $ea./
           
      | 'struct' struct_or_union_identifier '{' <openscope> struct_declaration_list_opt '}'
           /.$ba  consumeTypeSpecifierComposite(true, IASTCompositeTypeSpecifier.k_struct);  $ea./
           
      | 'union'  struct_or_union_identifier '{' <openscope> struct_declaration_list_opt '}'
           /.$ba  consumeTypeSpecifierComposite(true, IASTCompositeTypeSpecifier.k_union);  $ea./
           
      | 'struct' struct_or_union_identifier
           /.$ba  consumeTypeSpecifierElaborated(IASTElaboratedTypeSpecifier.k_struct);  $ea./
           
      | 'union'  struct_or_union_identifier
           /.$ba  consumeTypeSpecifierElaborated(IASTElaboratedTypeSpecifier.k_union);  $ea./


struct_or_union_identifier
    ::= 'identifier'
            /.$ba  consumeName();  $ea./

struct_declaration_list_opt
    ::= struct_declaration_list
      | $empty

struct_declaration_list
    ::= struct_declaration
      | struct_declaration_list struct_declaration
      

struct_declaration
    ::= specifier_qualifier_list <openscope> struct_declarator_list ';' -- regular declarators plus bit fields
            /.$ba  consumeStructDeclaration(true);  $ea./  -- TODO is it okay to reuse consumeDeclaration() ?
      | specifier_qualifier_list ';'
            /.$ba  consumeStructDeclaration(false);  $ea./


-- just reuse declaration_specifiers, makes grammar a bit more lenient but thats ok
specifier_qualifier_list
    ::= declaration_specifiers
    
    --type_specifier
    --       --/.$ba  consumeDeclarationSpecifiers(true);  $ea./
    --  | specifier_qualifier_list type_specifier 
    --       --/.$ba  consumeDeclarationSpecifiers(false); $ea./
    --  | type_qualifier
    --       --/.$ba  consumeDeclarationSpecifiers(true);  $ea./
    --  | specifier_qualifier_list type_qualifier 
    --       --/.$ba  consumeDeclarationSpecifiers(false); $ea./
           

struct_declarator_list
    ::= struct_declarator
      | struct_declarator_list ',' struct_declarator

struct_declarator
    ::= declarator
      | ':' constant_expression  
		/.$ba  consumeStructBitField(false);  $ea./
      | declarator ':' constant_expression		
        /.$ba  consumeStructBitField(true);   $ea./
		
		
enum_identifier
    ::= 'identifier'  /.$ba  consumeName();  $ea./
            
            
enum_specifier
    ::= 'enum' '{' <openscope> enumerator_list_opt '}'
           /.$ba  consumeTypeSpecifierEnumeration(false);  $ea./
           
      | 'enum' enum_identifier '{' <openscope> enumerator_list_opt '}'
           /.$ba  consumeTypeSpecifierEnumeration(true);  $ea./
           
      | 'enum' '{' <openscope> enumerator_list_opt ',' '}'
           /.$ba  consumeTypeSpecifierEnumeration(false);  $ea./
           
      | 'enum' enum_identifier '{' <openscope> enumerator_list_opt ',' '}'
           /.$ba  consumeTypeSpecifierEnumeration(true);  $ea./
           
      | 'enum' enum_identifier
           /.$ba  consumeTypeSpecifierElaborated(IASTElaboratedTypeSpecifier.k_enum);  $ea./
      
      
enumerator_list_opt
    ::= enumerator_list
      | $empty
  
enumerator_list
    ::= enumerator
      | enumerator_list ',' enumerator
      
      
enumerator
    ::= enum_identifier
           /.$ba  consumeEnumerator(false);  $ea./
      | enum_identifier '=' constant_expression
           /.$ba  consumeEnumerator(true);  $ea./
      
      
type_qualifier
    ::= 'const'      /.$ba  consumeToken();  $ea./
      | 'restrict'   /.$ba  consumeToken();  $ea./
      | 'volatile'   /.$ba  consumeToken();  $ea./

function_specifier
    ::= 'inline'     /.$ba  consumeToken();  $ea./
    

declarator
    ::= direct_declarator
      | <openscope> pointer direct_declarator
         /.$ba  consumeDeclaratorWithPointer(true);  $ea./


direct_declarator
    ::= 'identifier' 
         /.$ba  consumeDirectDeclaratorIdentifier();  $ea./
         
      | '(' declarator ')'
         /.$ba  consumeDirectDeclaratorBracketed();  $ea./

      | array_direct_declarator       
        
      | function_direct_declarator



array_direct_declarator
    ::= direct_declarator array_modifier
          /.$ba  consumeDirectDeclaratorArrayDeclarator();  $ea./



function_direct_declarator
    ::= direct_declarator '(' <openscope> parameter_type_list ')'
         /.$ba  consumeDirectDeclaratorFunctionDeclarator(true);  $ea./
      
      | direct_declarator '(' ')'
         /.$ba  consumeDirectDeclaratorFunctionDeclarator(false);  $ea./


function_declarator
    ::= function_direct_declarator
      | <openscope> pointer function_direct_declarator
          /.$ba  consumeDeclaratorWithPointer(true);  $ea./


-- This is a hack because the parser cannot tell the difference between 
-- plain identifiers and types. Because of this an identifier_list would
-- always be parsed as a parameter_type_list instead. In a KnR funciton
-- definition we can use the extra list of declarators to disambiguate.
-- This rule should be merged back into direct_declarator if type info is
-- added to the parser. 
knr_direct_declarator 
    ::= direct_declarator '(' <openscope> identifier_list ')'
         /.$ba  consumeDirectDeclaratorFunctionDeclaratorKnR();  $ea./


knr_function_declarator
    ::= knr_direct_declarator
      | <openscope> pointer knr_direct_declarator
         /.$ba  consumeDeclaratorWithPointer(true);  $ea./
                  

array_modifier 
    ::= '[' ']'
         /.$ba  consumeDirectDeclaratorArrayModifier(false);  $ea./
         
      | '[' <openscope> type_qualifier_list ']'
         /.$ba  consumeDirectDeclaratorModifiedArrayModifier(false, false, true,  false);  $ea./
       
      | '[' assignment_expression ']'
         /.$ba  consumeDirectDeclaratorArrayModifier(true );  $ea./
         
      | '[' <openscope> type_qualifier_list assignment_expression ']'
         /.$ba  consumeDirectDeclaratorModifiedArrayModifier(false, false, true,  true );  $ea./
         
      | '[' 'static' assignment_expression ']'
         /.$ba  consumeDirectDeclaratorModifiedArrayModifier(true,  false, false, true );  $ea./
         
      | '[' 'static' <openscope> type_qualifier_list assignment_expression ']'
         /.$ba  consumeDirectDeclaratorModifiedArrayModifier(true,  false, true,  true );  $ea./
      
      | '[' <openscope> type_qualifier_list 'static' assignment_expression ']'
         /.$ba  consumeDirectDeclaratorModifiedArrayModifier(true,  false, true,  true );  $ea./
      
      | '[' '*' ']'
         /.$ba  consumeDirectDeclaratorModifiedArrayModifier(false, true,  false, false);  $ea./

      | '[' <openscope> type_qualifier_list '*' ']'
         /.$ba  consumeDirectDeclaratorModifiedArrayModifier(false, true,  true,  false);  $ea./
         
         
pointer
    ::= '*'
        /.$ba  consumePointer();  $ea./
      | pointer '*' 
        /.$ba  consumePointer();  $ea./
      | '*' <openscope> type_qualifier_list
        /.$ba  consumePointerTypeQualifierList();  $ea./
      | pointer '*' <openscope> type_qualifier_list
        /.$ba  consumePointerTypeQualifierList();  $ea./

type_qualifier_list
    ::= type_qualifier
      | type_qualifier_list type_qualifier

parameter_type_list
    ::= parameter_list
      | parameter_list ',' '...'
      | '...'  -- not spec

parameter_list
    ::= parameter_declaration
      | parameter_list ',' parameter_declaration

parameter_declaration
    ::= declaration_specifiers init_declarator
          /.$ba  consumeParameterDeclaration(true);  $ea./
      | declaration_specifiers 
          /.$ba  consumeParameterDeclaration(false); $ea./
      | declaration_specifiers abstract_declarator
          /.$ba  consumeParameterDeclaration(true);  $ea./
          
          
identifier_list
    ::= 'identifier'
           /.$ba  consumeName();  $ea./
      | identifier_list ',' 'identifier'
           /.$ba  consumeName();  $ea./

type_name
    ::= specifier_qualifier_list
          /.$ba  consumeTypeId(false);  $ea./
      | specifier_qualifier_list abstract_declarator
          /.$ba  consumeTypeId(true);  $ea./


abstract_declarator  -- a declarator that does not include an identifier
    ::= <openscope> pointer
          /.$ba  consumeDeclaratorWithPointer(false);  $ea./
      | direct_abstract_declarator
      | <openscope> pointer direct_abstract_declarator
          /.$ba  consumeDeclaratorWithPointer(true);   $ea./


-- rewritten to use the more general array_modifier rule
direct_abstract_declarator
    ::= '(' abstract_declarator ')'
          /.$ba  consumeDirectDeclaratorBracketed();  $ea./
      
      | array_modifier
          /.$ba  consumeAbstractDeclaratorArrayModifier(false);  $ea./
          
      | direct_abstract_declarator array_modifier
          /.$ba  consumeAbstractDeclaratorArrayModifier(true);   $ea./
      
      | '(' ')'
          /.$ba  consumeAbstractDeclaratorFunctionDeclarator(false, false); $ea./
          
      | direct_abstract_declarator '(' ')'
          /.$ba  consumeAbstractDeclaratorFunctionDeclarator(true, false);  $ea./
          
      | '(' <openscope> parameter_type_list ')'
          /.$ba  consumeAbstractDeclaratorFunctionDeclarator(false, true);  $ea./
      
      | direct_abstract_declarator '(' <openscope> parameter_type_list ')'
          /.$ba  consumeAbstractDeclaratorFunctionDeclarator(true, true);   $ea./


initializer
    ::= assignment_expression
            /.$ba  consumeInitializer();  $ea./
      | '{' <openscope> initializer_list '}'
            /.$ba  consumeInitializerList();  $ea./
      | '{' <openscope> initializer_list ',' '}'
            /.$ba  consumeInitializerList();  $ea./


initializer_list
    ::= initializer
      | designated_initializer
      | initializer_list ',' initializer
      | initializer_list ',' designated_initializer
            


designated_initializer
    ::= <openscope> designation initializer
            /.$ba  consumeInitializerDesignated();  $ea./

designation
    ::= designator_list '='

designator_list
    ::= designator
      | designator_list designator

designator
    ::= '[' constant_expression ']'
           /.$ba  consumeDesignatorArrayDesignator();  $ea./
      | '.' 'identifier'		
           /.$ba  consumeDesignatorFieldDesignator();  $ea./
		
		
		

      
      


-------------------------------------------------------------------------------------------
-- External Definitions
-------------------------------------------------------------------------------------------

translation_unit
    ::= external_declaration_list
         /.$ba  consumeTranslationUnit();  $ea./
      | $empty
         /.$ba  consumeTranslationUnit();  $ea./

external_declaration_list
    ::= external_declaration
      | external_declaration_list external_declaration

external_declaration
    ::= function_definition
      | declaration
      | ';'
          /.$ba  consumeDeclarationEmpty(); $ea./
      | ERROR_TOKEN
	      /.$ba  consumeDeclarationProblem();  $ea./

-- The extra <openscope> nonterminal before declarator in this rule is only there
-- to avoid a shift/reduce error with the rule for declaration. 
function_definition
    ::= declaration_specifiers <openscope> function_declarator compound_statement
         /.$ba  consumeFunctionDefinition();  $ea./
      | declaration_specifiers <openscope> knr_function_declarator <openscope> declaration_list compound_statement
         /.$ba  consumeFunctionDefinitionKnR();  $ea./


declaration_list
    ::= declaration
      | declaration_list declaration

$End
















