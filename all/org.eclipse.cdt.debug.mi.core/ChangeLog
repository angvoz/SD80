2003-01-07 Alain Magloire

	* src/.../mi/core/MIInferior.java (getOutputStream): Remove useless assignement.
	* src/.../mi/core/MIPluging.java (debugLog): Not need to be static.
	* src/.../mi/core/cdi/EventManager.java (update): Remove useless assignement.

2003-01-06 Alain Magloire

	* build.properties: Patch from Judy Green.

2003-01-06 Alain Magloire

	* src/.../mi/core/cdi/BreapoinManager.java (createLocation): new method
	to create a breakoint with an address.
	* src/.../mi/core/cdi/Location.java (Location): New constructor takes
	an address as argument.

2003-01-03 Alain Magloire

	The Class creating the CDISession part of the initialization would call
		(gdb) set autosolib on
	this works fine for Unix system, but on Windows it throws an error
	failing the debugger.  Windows(Cygwin, MingWin) does not need any
	special initialization like solib-search-paths etc ..

	* src/.../mi/core/cdi/SourceManager.java (setAutoSolib): Takes a boolean argument
	to set the autosolib on or off.
	* src/.../mi/core/CygwinGDBDebugger.java(initializeLibraries):
	Empty method, cygwin does not need any special handling.
	* src/.../mi/core/GDBDebugger.java (initializeLibraries):
	Always call autosolib.


2003-01-02 Alain Magloire

	Bug when using recursive:
	int recursive(int x) {
		if (x > 10)
			recursive(++x);
		return 0;
	}
	
	The Variable Manager is caching the MI/GDB var-obj for speed.
	It is finding the object by looking at the name and the stack/thread,
	for recursive calls, this is wrong and the code would be full in
	thinking the variable "x"(see above) is the same object.  To make the distinction
	we use the depth "-stack-info-depth" that will be use also in the equality
	to make sure we identify an object uniquely.  In the recursive() case above
	because the depth is different, a new "x" object will be created.  The downside
	is that on certain platform doing deep recursive/stackframe, we have noticed
	that "-stack-info-depth" can be very long, test done for gdb/QNX with
	a stack depth of 1000.

	* src/.../mi/core/cdi/VariableManager.java (getElement):
	Use the depth when doing equal().
	(createElement): Save the depth of the stack part of the Element.

2003-01-02 Alain Magloire

	GDB/MI uses some oob reasons that was not documented for the watchpoints
		*stopped,reason="access-watchpoint-trigger"...
		*stopped,reason="read-watchpoint-trigger",...
	* src/.../mi/core/event/MIWatchpointTrigger.java (parse):
	check for "hw-awpt" and "hw-rwpt".
	* src/.../mi/core/RxThread.java (createEvents):
	Check for "access-watchpoint-trigger", "read-watchpoint-trigger.

2002-12-17 Alain Magloire

	* src/.../mi/core/cdi/Register.java (setFormat): bug fix
	The format variable was not set.

2002-12-05 Alain Magloire

	GDB/MI provides error messages in its log stream, one problem
	is that it is not consistent, for example doing:
	 (gdb) info threads
         & "info threads\n"
	which is obviously not an error.
	So we put the error stream output par of the exception so when
	it is relevant it shows in the Exception.
	MI2CDIException is the bridge class.

	* src/.../mi/core/cdi/BreakpoinManager.java:
	* src/.../mi/core/cdi/CSession.java:
	* src/.../mi/core/cdi/CTarget.java:
	* src/.../mi/core/cdi/CThread.java:
	* src/.../mi/core/cdi/MemoryBlock.java:
	* src/.../mi/core/cdi/MemoryManager.java:
	* src/.../mi/core/cdi/Register.java:
	* src/.../mi/core/cdi/RegisterManager.java:
	* src/.../mi/core/cdi/SourceManager.java:
	* src/.../mi/core/cdi/Value.java:
	* src/.../mi/core/cdi/Variable.java:
	* src/.../mi/core/cdi/VariableManager.java:

	* src/.../mi/core/command/Command.java (getMIInfo):
	When error get the log stream and put it in the MIException.
	* src/.../mi/core/event/MIErrorEvent.java:
	Get the log stream error also.
	* src/.../mi/core/MIException.java (getLogMessage): New method
	contains buffer output.
	* src/.../mi/core/RxThread.java (processMIOutput): get the
	oob arrays up so it can be use in MIErrorEvent.

2002-12-02 Alain Magloire

	* src/.../mi/core/cdi/CTarget.java (updateState): If we
	have the current thread id set it before, getCThread() if
	it is implemented with "info threads" can override it but
	"-stack-list-thread" does not give this information.
	* src/.../mi/core/cdi/ErrorInfo.java: New file
	* src/.../mi/core/cdi/EventManager.java (getReason): Return
	an ErrorInfo also.
	* src/.../mi/core/event/MIErroEvent.java: New file
	* src/.../mi/core/RxThread.java (processMIOutput):
	Generated MIErrorEvent for "^error".

2002-11-29 Alain Magloire

	* src/.../mi/core/cdi/EventManager.java (processSuspended):
	get the threadId.

2002-11-29 Alain Magloire

	* src/.../mi/core/cdi/MemoryBlock.java (setValue):
	Check if the change affects other block and fire MemoryChangedEvent
	when necessary.

2002-11-29 Alain Magloire

	* src/.../mi/core/event/MIBreakpointEvent.java:
	* src/.../mi/core/event/MIFunctionFinishedEvent.java:
	* src/.../mi/core/event/MILocationReachedEvent.java:
	* src/.../mi/core/event/MISignalEvent.java:
	* src/.../mi/core/event/MISteppingRangeEvent.java:
	* src/.../mi/core/event/MIStoppedEvent.java:
	* src/.../mi/core/event/MIWatchpointEvent.java:
	* src/.../mi/core/event/MIWatchpointTriggerEvent.java:
	* src/.../mi/core/RxThread.java:
	Some events like the temporary events, do not have
	any specific format but do provide a frame and a thread-id
	move the code in MIStoppedEvent.

2002-11-28 Alain Magloire

	* src/.../mi/core/cdi/MemoryBlock.java (setValue):  Only get a byte.

2002-11-28 Alain Magloire

	* src/.../mi/core/cdi/CTarget.java (runUntil): new method implemented.
	* src/.../mi/core/cdi/CThread.java (runUntil): new method implemented.

2002-11-26 Doug Schaefer

	* src/.../mi/core/CygwinGDBDebugger.java:
	New Debugger that provides the Cygwin Command Factory to the MISession
	* src/.../mi/core/command/CygwinCommandFactory.java:
	New Command Factory for Cygwin specific implementations of the commands
	* src/.../mi/core/command/CygwinMIEnvironmentDirectory.java:
	New.  Subclasses the MIEnvironmentDirectory command to convert the
	paths using cygpath.
	* plugin.xml:
	Defines the new debugger extension.

2002-11-25 Alain Magloire

	* src/.../mi/core/cdi/Watchpoint.java:
	Check if it was access point also.
	* src/.../mi/core/output/MIBreakInsertInfo.java (parse):
	Check for "wpt" variable.
	* src/.../mi/core/output/MIBreakpoint.java (IsWriteWatchpoint):
	implemented.

2002-11-20 Mikhail Khodjaiants
	Fix for bug 26595.
	* src/.../mi/core/cdi/MemoryManager.java (compareBlocks):
	If the start address of a memory block has changed fir 'changed' event 
	only for the corresponding bytes of the overlapping area of new and old blocks.
	
2002-11-19 Alain Magloire

	* src/.../mi/core/cdi/MemoryManager.java (compareBlocks):
	The startAddress() may have change for example if we were
	watching "char *p;" and the address move "p++".  Take this
	into account now.

2002-11-18 Alain Magloire

	* src/.../mi/core/cdi/StackFrame.java (getCurrentStackFrame):
	if the currentFrame was not set only get the top level
	frame for the current.
	* src/.../mi/core/cdi/CTarget.java (updateStateId):
	Set the currentThreads && currentThreadId.
	
2002-11-18 Alain Magloire

	* src/.../mi/core/cdi/CThread.java (getStackFrameCount):
	Set the new thread before getting the value and restore
	after.

2002-11-14 Alain Magloire

	This is needed in post-mortem, application doing a 
	very deep recursion and crashing the stack size, for example
	on GNU/Linux it may reach 200000 levels deep.  Trying to
	bring in the UI a bactrace tree of 200000 nodes is useless.
	The UI could check the count and do the appropriate action
	by showing ranges etc ..

	* src/.../mi/core/cdi/CThread.java (getStackFrame):
	new method with a hi and low.
	(getStackFrameCount): new method.
	* src/.../mi/core/command/CommandFactory.java (createMIStackInfoDepth):
	new method.
	* src/.../mi/core/command/MIStackInfoDepth.java (getMIStackInfoDepthInfo):
	new method.

2002-11-13 Dave Inglis
	* plugin.xml
	Added "native" cpu support.
	
2002-11-06 Alain Magloire

	* src/.../mi/core/cdi/StackFrame.java (getLocals):
	If an exception was thrown, the array may contain null
	entries.  Use a list and catch the exception.

2002-11-06 Alain Magloire

	* src/.../mi/core/cdi/StackFrame.java (getArguments):
	If an exception was thrown, the array may contain null
	entries.  Use and a List and catch the exception.

2002-11-05 Alain Magloire

	* src/.../mi/core/cdi/Register.java (setValue): Fire a
	MIRegisterChangedEvent when changing value.
	Fix PR:25730

2002-11-01 Alain Magloire

	The change in MISession(), will catch things like starting gdb-5.0
	with argument "-i mi1", that level of mi is not supported.

	* src/.../mi/core/cdi/MemoryBlock.java (refresh):  When doing the refresh
	check if other blocks wehre affected and update them.
	* src/.../mi/core/cdi/MemoryManager.java (update): Return the array of
	affected addresses.
	* src/.../mi/core/MIPlugin.java (createCSession): Do not throw an
	error when trying "set new-console", it does not work on Linux.
	* src/.../mi/core/MISession.java (MISession):  Check if the process
	terminated early, maybe because of wron arguments etc .. and throw
	the exception.

2002-11-1 David Inglis
	* src/.../mi/core/MIPlugin.java
	throw MIExceptions in createSession (not rethorwn IOExceptions)

2002-10-30 Alain Magloire

	* src/.../core/cdi/MemoryBlock.java (setDirty): When need a
	refresh setDirty() to true.
	(isDirty): Return the flag value.

	* src/.../core/cdi/MemoryManager.java (update): Check if
	the MemoryBlock isDirty().

2002-10-30 Alain Magloire

	* src/.../core/cdi/MemoryBlock.java (setValue): reuse refresh()
	to update the memory and fire any MemoryChangedEvents.

2002-10-26 Alain Magloire

	* src/.../core/cdi/MemoryBlock.java (setValue): Generate
	a MemoryChangeEvent when the value is set, gdb/mi will not
	do it.

2002-10-25 Alain Magloire

	* src/.../core/cdi/CThread.java (getStackFrames): Save the
	current thread before changing and restore when operation finish.

	* src/.../core/cdi/MemoryBlock.java (refresh):  Flush the old
	data and get new memory.
	(update): New method to compare individual blocks.

2002-10-25 Alain Magloire

	Automatically suspend/resume gdb when setting a breakpoint.
	The workflow when debuggin which gdb command prompt is to
	hit CTRL-C set the breakpoint and continue.  The UI debugger
	should be smart enought to do this by itself.  So if the
	inferior is running, when setting a breakpoint the program
	is suspended(target.suspend()), the suspend event is ignore
	the breakpoint is set (--break-insert) and the target is resume.
	To ignore a specific event, we use a (mis)behaviour of gdb that
	associate the suspend(*stopped) with the last execution command.
	(gdb)
	111-exec-continue
	111^running
	(gdb)
	222-exec-interrupt
	222^done
	(gdb)
	111*stopped,signal-name="SIGINT",signal-meaning="Interrupt",
	frame={addr="0x00010140",func="foo",args=[],file="try.c",line="13"}
	(gdb)
	In the case above event 111 is ignore.

	* src/.../core/command/CLICommand.java (toString): Always put
	the identifying token.
	* src/.../core/command/Command.java (setToken): Removed.
	(getUniqToken): New method returns a global uniq token.
	(getToken): Returns a uniq token for the command.
	* src/.../core/MIInferior.java (setTerminated): New argument token,
	since now all MIEvent has the corresponding command token.
	* src/.../core/MISession.java (cmdCount): Removed.
	(postCommand): the command getToken() will return a uniq token.
	* src/.../core/RxThread.java (processMIOOBRecord): MIEvent take
	the corresponding command token as argument.
	* src/.../core/TxThrea.java (token): Field removed, token are no
	longer created in this tread.
	* src/.../core/event/MIBreakpointEvent.java:
	* src/.../core/event/MIBreakpointEvent.java:
	* src/.../core/event/MIChangedEvent.java:
	* src/.../core/event/MIDetachedEvent.java:
	* src/.../core/event/MIEvent.java:
	* src/.../core/event/MIFunctionFinishedEvent.java:
	* src/.../core/event/MIGDBExitEvent.java:
	* src/.../core/event/MIInferiorExitEvent.java:
	* src/.../core/event/MILocationReachedEvent.java:
	* src/.../core/event/MIMemoryChangedEvent.java:
	* src/.../core/event/MIRegisterChangedEvent.java:
	* src/.../core/event/MIRunningEvent.java:
	* src/.../core/event/MISignalEvent.java:
	* src/.../core/event/MISteppingRangeEvent.java:
	* src/.../core/event/MIStoppedEvent.java:
	* src/.../core/event/MIThreadExitEvent.java:
	* src/.../core/event/MIVarChangedEvent.java:
	* src/.../core/event/MIWatchpointScopeEvent.java:
	* src/.../core/event/MIWatchpointTriggerEvent.java:
	Calls super with getToken().
	* src/.../core/cdi/BreakpointManager.java (allowProgramInterruption):
	New method to allow suspending the program to set a breakpoint.
	(suspendInferior): get the last token execution an ignore the suspend
	event.
	* src/.../core/cdi/CTarget.java (getLastExecutionToken): New method
	returns the token of the last execution command.
	* src/.../core/cdi/EventManager.java (enableEventToken): New method.
	(enableEventTokens): New method.
	(disableEventToken): New method.
	(disableEventTokens): New method.
	(update): Ignore token in the disable list.
	* src/.../core/cdi/RegisterManager.java (update): MIEvent takes
	a token.
	* src/.../core/cdi/Variable.java (setValue): MIEvent takes a token.
	* src/.../core/cdi/VariableManager.java (update): MIEvent takes a token.

2002-10-24 Alain Magloire

	* src/.../core/RxThread.java (processMIOutput): Fire a
	suspended event when seeing an error.

2002-10-24 Alain Magloire

	* src/.../core/output/MIConst.java (isoC): Change to return
	a string instead '\n' is platform dependent and has to be
	translate to "\r\n" for SWT widgets to work correctly on windows.

2002-10-23 Alain Magloire

	gdb/mi for program control command will fire a change state event:
	-exec-run
	^running
	This allow the UI to change its state and wait for the suspended.
	Providing a gdb prompt adds some problems, since there is no state
	change, i.e.(^running) after command like, next/step/...:
	next
	&"next\n"
	...
	So to palliate, the txthread do some query when the commands are
	CLI commands trying to discover the type and fire any appropriate
	events on behalf on gdb.

	* src/.../core/RxThread.java (createEvent): Adjust the parser to
	not rely on the oob "*stopped", since for CLI command it is not
	in the result-class.  So the suspended state will be base of
	the "reason" only.
	* src/.../core/TxThread.java (processCLICommand): new method,
	get the command and try to recognize if it is a program control
	command like: next, step, etc ..
	* src/.../core/command/CLICommand.java (getOperation): New method,
	returns the command string.

2002-10-22 Alain Magloire

	Change the framework to support access to gdb prompt.
	Trying to reuse as much as possible Eclipse framework.
	The session/gdb process is available via CDI.

	* src/.../core/GDBStreamsProxy.java: Removed.
	* src/.../core/GDBProcess.java: Removed.
	* src/.../core/GDBStreamMonitor.java: Removed.
	* src/.../core/SessionProcess.java: New file.
	* src/.../core/MISession.java (getMISessionProcess):
	New method, returns a "fake" Process that wraps the input/outpu
	stream of gdb.
	(getGDBProcess): was getMIProcess(), renamed.
	* src/.../core/cdi/CSession.java (getSessionProcess): New method
	return gdb process.

2002-10-22 Alain Magloire

	* src/.../core/GDBStreamsProxy.java (write):
	Replace the OutputStream with a Write class.
	And clear the buffer on flush().

2002-10-21 Alain Magloire

	* src/.../core/GDBProcess.java (getExitValue): Catch
	IllegalThreadStateException.
	(getAttribute): Only create Properties, when call.
	(setAttribute): Only create Properties, when call.
	(getAdapter): Implemented.
	(canTerminate): true only of the process is alive.
	(GDBProcess): Takes one more argument the name.
	* src/.../core/GDBStreamMonitor.java (fireStreamAppend): New method.
	Use a synchronized LinkedList for the listeners.
	(read): new Method.
	(startMonitoring): New method, start a thread in the background
	to monitor the input.
	* src/.../core/GDBStreamsProxy.java (getErrorStream): Start the monitor thread.
	(getOutputStream): Start the monitor thread.

2002-10-21 Alain Magloire

	Framework for having a gdb console.  The idea is to reuse
	the eclipse console and save a lot of work.  We "adapt"
	the gdb Process to what eclipse debug LaunchView wants(IProcess).
	So when this fake "gdb process" is selected we can grab the
	input/output of the console and redirect everything to raw gdb.

	* src/.../core/GDBProcess.java: New file, it implements Eclipse
	debug class IProcess.
	* src/.../core/GDBStreamMonitor: New file, it implements Eclipse
	debug class IStreamMonitor.
	* src/.../core/GDBStreamsProxy: New file, it implements Eclipse
	debug class IStreamsProxy.
	* src/../core/MISession.java (getMIConsoleStream): New method
	to return the mi console stream output that we get from gdb/mi.
	(getMILogStream): New method, to return the mi log stream output
	that we get from gdb/mi.
	(terminate): close the fake MI Console and Log streams. 
	* src/../core/RxThread.java (processMIOOBRecord): Redirect the
	console and the log stream to a buffer pipe.

2002-10-21 Alain Magloire

	* src/.../core/cdi/EventManager.java (update): Only
	fire the event for MemoryChangedEvent if the block was
	not frozen.

2002-10-20 Alain Magloire

	Eclipse provides plugins a way to trace by having an .options file,
	this mechanism is use to print out the mi exchange between gdb
	and the plugin.  To enable this in the debug launch one must enable
	"tracing" and set for the "org.eclipse.debug.mi.core/debug" to true.
	But one problem, the console will simply blow taking down eclipse,
	for big MI line response, say 4k length, for example asking the children
	of "char buffer[4096]", -var-list-children varxx.
	This seem only to happen in Eclipse-gtk or Eclipse-motif
	on GNU/Linux, so it will be break in smaller chunks to give a chance to
	the console.

	* .options: Set debug to true.
	* src/.../core/MIPlugin.java (debugLog): Break the log line in small chuncks of 100.
	* src/.../core/MISession.java (postCommand): Print the gdb/mi command.
	* src/.../core/RxThread.java (run): Print gdb/mi responses.

2002-10-20 Alain Magloire

	-data-write-register-values is not in the texinfo manual but implemented in
	gdb-5.2.1/gdb/mi/mim-main.c:
	Write given values into registers. The registers and values are
	given as pairs. The corresponding MI command is 
	-data-write-register-values <format> [<regnum1> <value1>...<regnumN> <valueN>]

	* src/.../core/command/MIDataWriteRegisterValues.java: New file.
	* src/.../core/command/CommandFactory.java (createMIDataWriteMemory): New method.
	* src/.../core/cdi/Register.java (setValue): Implemented.
	
2002-10-20 Alain Magloire

	Althought -data-write-memory is not documented in the texinfo manual
	it is implemented and well documented in the code(gdb-5.2.1/gdb/mi/mi-main.c).
	"mi_cmd_data_write_memory: Usage: [-o COLUMN_OFFSET] ADDR FORMAT WORD-SIZE VALUE.");

	* src/.../core/command/MIDataWriteMemory.java: New file
	* src/.../core/command/CommandFactory.java (createMIDataWriteMemory): New method.
	* src/.../core/cdi/MemoryBlock.java (setValue): Implemented.

2002-10-20 Alain Magloire

	* src/.../core/cdi/CTarget.java (getMemoryBlock): Remove
	we use the MemoryManager instead.
	(EvaluateExpressionToValue): Removed not use.
	* src/.../core/cdi/SourceManager.java (setFile): Removed not use.
	(getFile): Removed not use.
	(reset): Removed not use.

2002-10-19 Alain Magloire

	The responsability to generate Events for modify memory blocks is push
	on the CDI implementation.  The way we do this is every time consuming,
	when the inferior is suspended(see EventManager.processSuspendedEvent()),
	MemoryManager.update() is called, the method will go through the list of MemoryBlocks
	that are not MemoryBlocks.setFrozen() and fetch the new memories, the data is compare
	and MemoryChangedEvents are fired for blocks with changed values.
	Gdb/mi var objects does not seem to provide any support for Memory ranges.

	* src/.../core/cdi/MemoryChangedEvent.java: New File implements ICDIMemoryChangedEvent.
	* src/.../core/cdi/EventManager.java (update): Process MIMemoryChangedEvent's.
	(processSuspendedEvent): call MemoryManager.update().
	* src/.../core/cdi/MemoryBlock.java (getExpression): New method.
	(getMIDataReadMemoryInfo): New method.
	(setMIDataReadMemoryInfo): New method.
	* src/.../core/cdi/MemoryManager.java (update): New method.
	(compareBlock): New method.
	(listMemoryBlocks): New method.

	* src/.../core/cdi/CTarget.java (setCurrentThread): Catch null pointer.
	(getCThreads): Likewise.
	* src/.../core/event/MIMemoryChangedEvent.java: New File.
	* src/.../core/event/MIThreadExitEvent.java: Indentation fixes.
	* src/.../core/event/MIVarChangedEvent.java: Indentation fixes.


	
2002-10-16 Alain Magloire

	* src/.../mi/core/cdi/MemoryManager.java (createMemoryBlock):
	New method that takes a string instead of a long, rearrange
	the method for it.

2002-10-12 Alain Magloire

	There are some serious problems with gdb/mi, for example
	the most recurrent one is when using -data-disassemble
	in a threaded program, GNU/Linux uses a thread manager
	when trying to access the stackframe, gdb usually coredumps
	with an assert, it goes something like this:
	
-data-disassemble -f manager.c -l 136 -n 100 0
&"Cannot access memory at address 0x4002d794\n"
^error,msg="Cannot access memory at address 0x4002d794"
(gdb) 
-data-disassemble -s 0x4002d900 -e 0x4002d964 0
&"Cannot access memory at address 0x4002d900\n"
^error,msg="Cannot access memory at address 0x4002d900"
(gdb) 
-thread-select 2
&"ui-out.c:133: gdb-internal-error: push_level: Assertion `uiout->level >= 0 && uiout->level < MAX_UI_OUT_LEVELS' failed.\n"

	The RxThread will spawn a thread to terminate the session
	and clear the receiving queue.


	* RxThread.java (run): When the thread is being cancel() or
	running out of run(), clear the receiving queue(rxQueue) and
	notify any commands waiting.

	* TxTread.java (run): Before putting the command in the
	receiving queue(rxQueue) check to see if the thread is
	still running.
	When the thread is being cancel() or running out of run(),
	clear the transmition queue(txQueue) an notify any commands
	waiting.

	* Queue.java (clearItems): New method that clear the items
	on the queue and returning them.

	* CommandQueue.java (clearCommands): New method calls super.clearItems()
	whith the appropriate castings.

	* cdi/CThread.java (setCurrentStackFrame): Check for null.

2002-10-12 Alain Magloire

	The memory block is implemented with
	-data-read-memory (MIDataReadMemory)
	Since the ICDIMemoryBlock only have
	byte[] getBytes()
	We will always issue:
	-data-read-memory address x 1 1 length
	The CDI upper layer will deal with any conversions
	
	The problem now is how to send changedEvent when
	an element of the memory changed.
	
	* cdi/MemoryBlock.java (getLength): Implemented
	(getBytes): Implemented
	(getStartAddress): Implemented

	* cdi/MemoryManager.java: Implemented.
	
	* command/MIDataReadMemory (getMIDataReadMemoryInfo):
	New helper method.

2002-10-12 Alain Magloire

	* cdi/Location (getInstructions): Methods removed
	no longer define in ICDILocation.

2002-10-11 Alain Magloire

	* cdi/SourceManager (getMixedInstruction):
	Implement the 3 new methods to return Mixed source
	and assemby instructions.
	
	* cdi/MixedInstruction: New class implements
	ICDIMixedInstruction.

2002-10-11 Alain Magloire

	* cdi/ExpressionManager.java:  Not needed, removed.

2002-10-10 Alain Magloire

	The Eclipse/UI/Debug framewok is being very repetive
	and each command can be ask 2, 3 times.  So we'll try
	to make certain commands smarter by not reissuing them
	to gdb if the state is the same.  We do this when
	selecting the thread and when selecting the stackframe.
	
	The other problem is that Eclipse/UI/Debug is calling
	ICDISession.terminate() twice, this is catch by looking
	at isTerminated().

	* cdi/CThread.java (setCurrentStackFrame): Make it smarter
	to not reselect the stack level if it is already at that
	level.

	* MISession.java (isTerminated): Declare a flag that will
	hold the state.
	(terminate): Check if it was call already.

2002-10-10 Alain Magloire

	* SourceManager.java:  Implement getInstructions().
