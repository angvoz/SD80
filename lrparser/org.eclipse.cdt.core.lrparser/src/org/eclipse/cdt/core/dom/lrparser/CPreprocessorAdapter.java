/*******************************************************************************
 * Copyright (c) 2006, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/
package org.eclipse.cdt.core.dom.lrparser;

import lpg.lpgjavaruntime.IToken;
import lpg.lpgjavaruntime.Token;

import org.eclipse.cdt.core.dom.ast.IASTTranslationUnit;
import org.eclipse.cdt.core.dom.lrparser.action.ITokenMap;
import org.eclipse.cdt.core.parser.EndOfFileException;
import org.eclipse.cdt.core.parser.IScanner;

/**
 * Adapts the CPreprocessor from the CDT core for use with LPG based parsers.
 * 
 * @author Mike Kucera
 *
 */
class CPreprocessorAdapter {

	/**
	 * During content assist the preprocessor may return a completion token
	 * which represents the identifier on which the user invoked content assist.
	 * The the preprocessor normally returns arbitrarily many end-of-completion 
	 * (EOC) tokens.
	 * 
	 * A bottom-up parser cannot know ahead of time how many EOC tokens are
	 * needed in order for the parse to complete successfully. So we pick
	 * a number that seems arbitrarily large enough.
	 */
	private static final int NUM_EOC_TOKENS = 50;
	
	private static final int DUMMY_TOKEN_KIND = 0;
	
	
	private static final int tCOMPLETION   = org.eclipse.cdt.core.parser.IToken.tCOMPLETION;
	private static final int tEND_OF_INPUT = org.eclipse.cdt.core.parser.IToken.tEND_OF_INPUT;
	private static final int tEOC          = org.eclipse.cdt.core.parser.IToken.tEOC;
	
	
	
	/** 
	 * Collect the tokens generated by the preprocessor.
	 * 
	 * TODO: should preprocessor.nextTokenRaw() be called instead?
	 */
	@SuppressWarnings("restriction")
	public static void runCPreprocessor(IScanner preprocessor, ITokenCollector tokenCollector, ITokenMap tokenMap, IASTTranslationUnit tu) {
		// LPG requires that the token stream start with a dummy token
		tokenCollector.addToken(createDummyToken());
		
		preprocessor.getLocationResolver().setRootNode(tu);
		
		try {
			while(true) {
				org.eclipse.cdt.core.parser.IToken domToken = preprocessor.nextToken(); // throws EndOfFileException
				int type = domToken.getType();
				
				IToken token = new LPGTokenAdapter(domToken, tokenMap.mapKind(type));
				tokenCollector.addToken(token);
				
				if(type == tCOMPLETION) {
					// the token after the completion token must be an EOC token
					org.eclipse.cdt.core.parser.IToken domEocToken = preprocessor.nextToken();
					assert domEocToken.getType() == tEOC;
					
					IToken eocToken = createEOCToken(domEocToken, tokenMap);
					
					for(int i = 0; i < NUM_EOC_TOKENS; i++)
						tokenCollector.addToken(eocToken); // reuse the same reference, no need to create several objects

					break;
				}
			}
		} catch (EndOfFileException e) {
			// just break out of the loop
		}
		
		// LPG requires that the token stream end with an EOF token
		tokenCollector.addToken(createEOFToken(tokenMap));
	}
	
	
	
	
	private static IToken createEOCToken(org.eclipse.cdt.core.parser.IToken domEocToken, ITokenMap tokenMap) {
		return new LPGTokenAdapter(domEocToken, tokenMap.mapKind(domEocToken.getType()));
	}
	
	private static IToken createDummyToken() {
		return new Token(null, 0, 0, DUMMY_TOKEN_KIND);
	}
	
	private static IToken createEOFToken(ITokenMap tokenMap) {
		return new Token(null, 0, 0, tokenMap.mapKind(tEND_OF_INPUT));
	}
	
	
}
