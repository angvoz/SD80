/*******************************************************************************
* Copyright (c) 2006, 2008 IBM Corporation and others.
* All rights reserved. This program and the accompanying materials
* are made available under the terms of the Eclipse Public License v1.0
* which accompanies this distribution, and is available at
* http://www.eclipse.org/legal/epl_v10.html
*
* Contributors:
*     IBM Corporation - initial API and implementation
*********************************************************************************/

// This file was generated by LPG

package org.eclipse.cdt.internal.core.dom.lrparser.cpp;

import lpg.lpgjavaruntime.*;

import java.util.*;

import org.eclipse.cdt.core.dom.ast.*;
import org.eclipse.cdt.core.dom.ast.cpp.*;
import org.eclipse.cdt.core.dom.lrparser.action.cpp.CPPASTNodeFactory;
import org.eclipse.cdt.core.dom.lrparser.action.cpp.CPPBuildASTParserAction;
import org.eclipse.cdt.core.dom.lrparser.IParser;
import org.eclipse.cdt.core.dom.lrparser.IParserActionTokenProvider;
import org.eclipse.cdt.core.dom.lrparser.util.DebugUtil;

public class CPPParser extends PrsStream implements RuleAction , IParserActionTokenProvider, IParser 
{
    private static ParseTable prs = new CPPParserprs();
    private BacktrackingParser btParser;

    public BacktrackingParser getParser() { return btParser; }
    private void setResult(Object object) { btParser.setSym1(object); }
    public Object getRhsSym(int i) { return btParser.getSym(i); }

    public int getRhsTokenIndex(int i) { return btParser.getToken(i); }
    public IToken getRhsIToken(int i) { return super.getIToken(getRhsTokenIndex(i)); }
    
    public int getRhsFirstTokenIndex(int i) { return btParser.getFirstToken(i); }
    public IToken getRhsFirstIToken(int i) { return super.getIToken(getRhsFirstTokenIndex(i)); }

    public int getRhsLastTokenIndex(int i) { return btParser.getLastToken(i); }
    public IToken getRhsLastIToken(int i) { return super.getIToken(getRhsLastTokenIndex(i)); }

    public int getLeftSpan() { return btParser.getFirstToken(); }
    public IToken getLeftIToken()  { return super.getIToken(getLeftSpan()); }

    public int getRightSpan() { return btParser.getLastToken(); }
    public IToken getRightIToken() { return super.getIToken(getRightSpan()); }

    public int getRhsErrorTokenIndex(int i)
    {
        int index = btParser.getToken(i);
        IToken err = super.getIToken(index);
        return (err instanceof ErrorToken ? index : 0);
    }
    public ErrorToken getRhsErrorIToken(int i)
    {
        int index = btParser.getToken(i);
        IToken err = super.getIToken(index);
        return (ErrorToken) (err instanceof ErrorToken ? err : null);
    }

    public CPPParser(LexStream lexStream)
    {
        super(lexStream);

        try
        {
            super.remapTerminalSymbols(orderedTerminalSymbols(), CPPParserprs.EOFT_SYMBOL);
        }
        catch(NullExportedSymbolsException e) {
        }
        catch(NullTerminalSymbolsException e) {
        }
        catch(UnimplementedTerminalsException e)
        {
            java.util.ArrayList unimplemented_symbols = e.getSymbols();
            System.out.println("The Lexer will not scan the following token(s):");
            for (int i = 0; i < unimplemented_symbols.size(); i++)
            {
                Integer id = (Integer) unimplemented_symbols.get(i);
                System.out.println("    " + CPPParsersym.orderedTerminalSymbols[id.intValue()]);               
            }
            System.out.println();                        
        }
        catch(UndefinedEofSymbolException e)
        {
            throw new Error(new UndefinedEofSymbolException
                                ("The Lexer does not implement the Eof symbol " +
                                 CPPParsersym.orderedTerminalSymbols[CPPParserprs.EOFT_SYMBOL]));
        } 
    }

    public String[] orderedTerminalSymbols() { return CPPParsersym.orderedTerminalSymbols; }
    public String getTokenKindName(int kind) { return CPPParsersym.orderedTerminalSymbols[kind]; }
    public int getEOFTokenKind() { return CPPParserprs.EOFT_SYMBOL; }
    public PrsStream getParseStream() { return (PrsStream) this; }
    
    //
    // Report error message for given error_token.
    //
    public final void reportErrorTokenMessage(int error_token, String msg)
    {
        int firsttok = super.getFirstErrorToken(error_token),
            lasttok = super.getLastErrorToken(error_token);
        String location = super.getFileName() + ':' +
                          (firsttok > lasttok
                                    ? (super.getEndLine(lasttok) + ":" + super.getEndColumn(lasttok))
                                    : (super.getLine(error_token) + ":" +
                                       super.getColumn(error_token) + ":" +
                                       super.getEndLine(error_token) + ":" +
                                       super.getEndColumn(error_token)))
                          + ": ";
        super.reportError((firsttok > lasttok ? ParseErrorCodes.INSERTION_CODE : ParseErrorCodes.SUBSTITUTION_CODE), location, msg);
    }

    public Object parser()
    {
        return parser(null, 0);
    }
    
    public Object parser(Monitor monitor)
    {
        return parser(monitor, 0);
    }
    
    public Object parser(int error_repair_count)
    {
        return parser(null, error_repair_count);
    }

    public Object parser(Monitor monitor, int error_repair_count)
    {
        try
        {
            btParser = new BacktrackingParser(monitor, (TokenStream) this, prs, (RuleAction) this);
        }
        catch (NotBacktrackParseTableException e)
        {
            throw new Error(new NotBacktrackParseTableException
                                ("Regenerate CPPParserprs.java with -BACKTRACK option"));
        }
        catch (BadParseSymFileException e)
        {
            throw new Error(new BadParseSymFileException("Bad Parser Symbol File -- CPPParsersym.java"));
        }

        try
        {
            return (Object) btParser.parse(error_repair_count);
        }
        catch (BadParseException e)
        {
            reset(e.error_token); // point to error token
            DiagnoseParser diagnoseParser = new DiagnoseParser(this, prs);
            diagnoseParser.diagnose(e.error_token);
        }

        return null;
    }


private  CPPParserAction  action;	

// uncomment to use with backtracking parser
public CPPParser() {}

private void initActions(IASTTranslationUnit tu) {
    // binding resolution actions need access to IASTName nodes, temporary
    action = new  CPPParserAction ();
	//action.resolver = new  C99TypedefTrackerParserAction (this);
	action.builder  = new  CPPBuildASTParserAction ( CPPASTNodeFactory.DEFAULT_INSTANCE , this, tu);
	//action.builder.setTokenMap(CPPParsersym.orderedTerminalSymbols);
	
	// comment this line to use with backtracking parser
	//setParserAction(action);
}


public void addToken(IToken token) {
	token.setKind(mapKind(token.getKind()));
	super.addToken(token);
}


public IASTCompletionNode parse(IASTTranslationUnit tu) {
	// this has to be done, or... kaboom!
	setStreamLength(getSize());
	initActions(tu);
	
	final int errorRepairCount = -1;  // _1 means full error handling
	parser(null, errorRepairCount); // do the actual parse
	super.resetTokenStream(); // allow tokens to be garbage collected

	// the completion node may be null
	IASTCompletionNode compNode = action.builder.getASTCompletionNode();

	action = null;
	
	// Comment this line to use with backtracking parser
	//parserAction = null;
	
	return compNode;
}


public int getKind(int i) {
	int kind = super.getKind(i);
	
	// There used to be a special token kind for zero used to parser pure virtual function declarations.
	// But it turned out to be easier to just parse them as an init_declarator and programaticaly check
	// for pure virtual, see consumeMemberDeclaratorWithInitializer().
	
	//if(kind == CPPParsersym.TK_integer && "0".equals(getTokenText(i))) { //$NON-NLS-1$
	//	kind = CPPParsersym.TK_zero;
	//}
	
	// lexer feedback hack!
	//else if(kind == C99Parsersym.TK_identifier && action.resolver.isTypedef(getTokenText(i))) {
	//	kind = C99Parsersym.TK_TypedefName;
	//}
	
	return kind;
}


// uncomment this method to use with backtracking parser
public List getRuleTokens() {
    return Collections.unmodifiableList(getTokens().subList(getLeftSpan(), getRightSpan() + 1));
}



    public void ruleAction(int ruleNumber)
    {
        switch (ruleNumber)
        {
  
            //
            // Rule 1:  <openscope-ast> ::= $Empty
            //
            case 1: {       action.builder.
  openASTScope();                break;
            }
  
            //
            // Rule 4:  <placeholder> ::= $Empty
            //
            case 4: {       action.builder.
  consumePlaceHolder();                break;
            }
  
            //
            // Rule 5:  <empty> ::= $Empty
            //
            case 5: {       action.builder.
  consumeEmpty();                break;
            }
   
            //
            // Rule 10:  translation_unit ::= declaration_seq
            //
            case 10: {       action.builder.
   consumeTranslationUnit();                break;
            }  
   
            //
            // Rule 11:  translation_unit ::= $Empty
            //
            case 11: {       action.builder.
   consumeTranslationUnit();                break;
            }  
   
            //
            // Rule 12:  literal ::= integer
            //
            case 12: {       action.builder.
   consumeExpressionLiteral(ICPPASTLiteralExpression.lk_integer_constant);                break;
            }  
   
            //
            // Rule 13:  literal ::= 0
            //
            case 13: {       action.builder.
   consumeExpressionLiteral(ICPPASTLiteralExpression.lk_integer_constant);                break;
            }  
   
            //
            // Rule 14:  literal ::= floating
            //
            case 14: {       action.builder.
   consumeExpressionLiteral(ICPPASTLiteralExpression.lk_float_constant);                break;
            }  
   
            //
            // Rule 15:  literal ::= charconst
            //
            case 15: {       action.builder.
   consumeExpressionLiteral(ICPPASTLiteralExpression.lk_char_constant);                break;
            }  
   
            //
            // Rule 16:  literal ::= stringlit
            //
            case 16: {       action.builder.
   consumeExpressionLiteral(ICPPASTLiteralExpression.lk_string_literal);                break;
            }  
   
            //
            // Rule 17:  literal ::= true
            //
            case 17: {       action.builder.
   consumeExpressionLiteral(ICPPASTLiteralExpression.lk_true);                break;
            }  
   
            //
            // Rule 18:  literal ::= false
            //
            case 18: {       action.builder.
   consumeExpressionLiteral(ICPPASTLiteralExpression.lk_false);                break;
            }  
   
            //
            // Rule 19:  literal ::= this
            //
            case 19: {       action.builder.
   consumeExpressionLiteral(ICPPASTLiteralExpression.lk_this);                break;
            }  
   
            //
            // Rule 21:  primary_expression ::= ( expression )
            //
            case 21: {       action.builder.
   consumeExpressionBracketed();                 break;
            }  
   
            //
            // Rule 23:  id_expression ::= qualified_or_unqualified_name
            //
            case 23: {       action.builder.
   consumeExpressionName();                 break;
            }  
   
            //
            // Rule 30:  unqualified_id_name ::= ~ class_name
            //
            case 30: {       action.builder.
   consumeDestructorName();                 break;
            }  
   
            //
            // Rule 31:  identifier_name ::= identifier
            //
            case 31: {       action.builder.
   consumeIdentifierName();                 break;
            }  
   
            //
            // Rule 32:  template_opt ::= template
            //
            case 32: {       action.builder.
   consumePlaceHolder();                 break;
            }  
   
            //
            // Rule 33:  template_opt ::= $Empty
            //
            case 33: {       action.builder.
   consumeEmpty();                 break;
            }  
   
            //
            // Rule 34:  dcolon_opt ::= ::
            //
            case 34: {       action.builder.
   consumePlaceHolder();                 break;
            }  
   
            //
            // Rule 35:  dcolon_opt ::= $Empty
            //
            case 35: {       action.builder.
   consumeEmpty();                 break;
            }  
   
            //
            // Rule 36:  qualified_id_name ::= dcolon_opt nested_name_specifier template_opt unqualified_id_name
            //
            case 36: {       action.builder.
   consumeQualifiedId(true);                 break;
            }  
   
            //
            // Rule 37:  qualified_id_name ::= :: identifier_name
            //
            case 37: {       action.builder.
   consumeGlobalQualifiedId();                 break;
            }  
   
            //
            // Rule 38:  qualified_id_name ::= :: operator_function_id_name
            //
            case 38: {       action.builder.
   consumeGlobalQualifiedId();                 break;
            }  
   
            //
            // Rule 39:  qualified_id_name ::= :: template_id_name
            //
            case 39: {       action.builder.
   consumeGlobalQualifiedId();                 break;
            }  
   
            //
            // Rule 40:  nested_name_specifier ::= class_or_namespace_name :: nested_name_specifier_with_template
            //
            case 40: {       action.builder.
   consumeNestedNameSpecifier(true);                 break;
            }  
   
            //
            // Rule 41:  nested_name_specifier ::= class_or_namespace_name ::
            //
            case 41: {       action.builder.
   consumeNestedNameSpecifier(false);                 break;
            }  
   
            //
            // Rule 42:  nested_name_specifier_with_template ::= class_or_namespace_name_with_template :: nested_name_specifier_with_template
            //
            case 42: {       action.builder.
   consumeNestedNameSpecifier(true);                 break;
            }  
   
            //
            // Rule 43:  nested_name_specifier_with_template ::= class_or_namespace_name_with_template ::
            //
            case 43: {       action.builder.
   consumeNestedNameSpecifier(false);                 break;
            }  
   
            //
            // Rule 44:  class_or_namespace_name_with_template ::= template_opt class_or_namespace_name
            //
            case 44: {       action.builder.
   consumeNameWithTemplateKeyword();                 break;
            }  
   
            //
            // Rule 46:  nested_name_specifier_opt ::= $Empty
            //
            case 46: {       action.builder.
   consumeNestedNameSpecifierEmpty();                 break;
            }  
   
            //
            // Rule 50:  postfix_expression ::= postfix_expression [ expression ]
            //
            case 50: {       action.builder.
   consumeExpressionArraySubscript();                 break;
            }  
   
            //
            // Rule 51:  postfix_expression ::= postfix_expression ( expression_list_opt )
            //
            case 51: {       action.builder.
   consumeExpressionFunctionCall();                 break;
            }  
   
            //
            // Rule 52:  postfix_expression ::= simple_type_specifier ( expression_list_opt )
            //
            case 52: {       action.builder.
   consumeExpressionSimpleTypeConstructor();                break;
            }  
   
            //
            // Rule 53:  postfix_expression ::= typename dcolon_opt nested_name_specifier <empty> identifier_name ( expression_list_opt )
            //
            case 53: {       action.builder.
   consumeExpressionTypeName();                break;
            }  
   
            //
            // Rule 54:  postfix_expression ::= typename dcolon_opt nested_name_specifier template_opt template_id_name ( expression_list_opt )
            //
            case 54: {       action.builder.
   consumeExpressionTypeName();                break;
            }  
   
            //
            // Rule 55:  postfix_expression ::= postfix_expression . qualified_or_unqualified_name
            //
            case 55: {       action.builder.
   consumeExpressionFieldReference(false, false);                 break;
            }  
   
            //
            // Rule 56:  postfix_expression ::= postfix_expression -> qualified_or_unqualified_name
            //
            case 56: {       action.builder.
   consumeExpressionFieldReference(true, false);                 break;
            }  
   
            //
            // Rule 57:  postfix_expression ::= postfix_expression . template qualified_or_unqualified_name
            //
            case 57: {       action.builder.
   consumeExpressionFieldReference(false, true);                 break;
            }  
   
            //
            // Rule 58:  postfix_expression ::= postfix_expression -> template qualified_or_unqualified_name
            //
            case 58: {       action.builder.
   consumeExpressionFieldReference(true, true);                 break;
            }  
   
            //
            // Rule 59:  postfix_expression ::= postfix_expression . pseudo_destructor_name
            //
            case 59: {       action.builder.
   consumeExpressionFieldReference(false, false);                 break;
            }  
   
            //
            // Rule 60:  postfix_expression ::= postfix_expression -> pseudo_destructor_name
            //
            case 60: {       action.builder.
   consumeExpressionFieldReference(true, false);                 break;
            }  
   
            //
            // Rule 61:  postfix_expression ::= postfix_expression ++
            //
            case 61: {       action.builder.
   consumeExpressionUnaryOperator(IASTUnaryExpression.op_postFixIncr);                 break;
            }  
   
            //
            // Rule 62:  postfix_expression ::= postfix_expression --
            //
            case 62: {       action.builder.
   consumeExpressionUnaryOperator(IASTUnaryExpression.op_postFixDecr);                 break;
            }  
   
            //
            // Rule 63:  postfix_expression ::= dynamic_cast < type_id > ( expression )
            //
            case 63: {       action.builder.
   consumeExpressionCast(ICPPASTCastExpression.op_dynamic_cast);                 break;
            }  
   
            //
            // Rule 64:  postfix_expression ::= static_cast < type_id > ( expression )
            //
            case 64: {       action.builder.
   consumeExpressionCast(ICPPASTCastExpression.op_static_cast);                 break;
            }  
   
            //
            // Rule 65:  postfix_expression ::= reinterpret_cast < type_id > ( expression )
            //
            case 65: {       action.builder.
   consumeExpressionCast(ICPPASTCastExpression.op_reinterpret_cast);                 break;
            }  
   
            //
            // Rule 66:  postfix_expression ::= const_cast < type_id > ( expression )
            //
            case 66: {       action.builder.
   consumeExpressionCast(ICPPASTCastExpression.op_const_cast);                 break;
            }  
   
            //
            // Rule 67:  postfix_expression ::= typeid ( expression )
            //
            case 67: {       action.builder.
   consumeExpressionUnaryOperator(ICPPASTUnaryExpression.op_typeid);                 break;
            }  
   
            //
            // Rule 68:  postfix_expression ::= typeid ( type_id )
            //
            case 68: {       action.builder.
   consumeExpressionTypeId(ICPPASTTypeIdExpression.op_typeid);                break;
            }  
   
            //
            // Rule 69:  pseudo_destructor_name ::= dcolon_opt nested_name_specifier_opt type_name :: ~ type_name
            //
            case 69: {       action.builder.
   consumePsudoDestructorName(true);                 break;
            }  
   
            //
            // Rule 70:  pseudo_destructor_name ::= dcolon_opt nested_name_specifier template template_id_name :: ~ type_name
            //
            case 70: {       action.builder.
   consumePsudoDestructorName(true);                 break;
            }  
   
            //
            // Rule 71:  pseudo_destructor_name ::= dcolon_opt nested_name_specifier_opt ~ type_name
            //
            case 71: {       action.builder.
   consumePsudoDestructorName(false);                 break;
            }  
   
            //
            // Rule 75:  unary_expression ::= ++ cast_expression
            //
            case 75: {       action.builder.
   consumeExpressionUnaryOperator(IASTUnaryExpression.op_prefixIncr);                 break;
            }  
   
            //
            // Rule 76:  unary_expression ::= -- cast_expression
            //
            case 76: {       action.builder.
   consumeExpressionUnaryOperator(IASTUnaryExpression.op_prefixDecr);                 break;
            }  
   
            //
            // Rule 77:  unary_expression ::= & cast_expression
            //
            case 77: {       action.builder.
   consumeExpressionUnaryOperator(IASTUnaryExpression.op_amper);                 break;
            }  
   
            //
            // Rule 78:  unary_expression ::= * cast_expression
            //
            case 78: {       action.builder.
   consumeExpressionUnaryOperator(IASTUnaryExpression.op_star);                 break;
            }  
   
            //
            // Rule 79:  unary_expression ::= + cast_expression
            //
            case 79: {       action.builder.
   consumeExpressionUnaryOperator(IASTUnaryExpression.op_plus);                 break;
            }  
   
            //
            // Rule 80:  unary_expression ::= - cast_expression
            //
            case 80: {       action.builder.
   consumeExpressionUnaryOperator(IASTUnaryExpression.op_minus);                 break;
            }  
   
            //
            // Rule 81:  unary_expression ::= ~ cast_expression
            //
            case 81: {       action.builder.
   consumeExpressionUnaryOperator(IASTUnaryExpression.op_tilde);                 break;
            }  
   
            //
            // Rule 82:  unary_expression ::= ! cast_expression
            //
            case 82: {       action.builder.
   consumeExpressionUnaryOperator(IASTUnaryExpression.op_not);                 break;
            }  
   
            //
            // Rule 83:  unary_expression ::= sizeof unary_expression
            //
            case 83: {       action.builder.
   consumeExpressionUnaryOperator(IASTUnaryExpression.op_sizeof);                 break;
            }  
   
            //
            // Rule 84:  unary_expression ::= sizeof ( type_id )
            //
            case 84: {       action.builder.
   consumeExpressionTypeId(ICPPASTTypeIdExpression.op_sizeof);                break;
            }  
   
            //
            // Rule 85:  new_expression ::= dcolon_opt new new_placement_opt new_type_id <openscope-ast> new_array_expressions_opt new_initializer_opt
            //
            case 85: {       action.builder.
   consumeExpressionNew(false);                 break;
            }  
   
            //
            // Rule 86:  new_expression ::= dcolon_opt new new_placement_opt ( type_id ) new_initializer_opt
            //
            case 86: {       action.builder.
   consumeExpressionNew(true);                 break;
            }  
   
            //
            // Rule 89:  new_placement_opt ::= $Empty
            //
            case 89: {       action.builder.
   consumeEmpty();                 break;
            }  
   
            //
            // Rule 90:  new_type_id ::= type_specifier_seq
            //
            case 90: {       action.builder.
   consumeTypeId(false);                 break;
            }  
   
            //
            // Rule 91:  new_type_id ::= type_specifier_seq new_declarator
            //
            case 91: {       action.builder.
   consumeTypeId(true);                 break;
            }  
   
            //
            // Rule 92:  new_declarator ::= <openscope-ast> new_pointer_operators
            //
            case 92: {       action.builder.
   consumeNewDeclarator();                break;
            }  
   
            //
            // Rule 101:  new_initializer_opt ::= $Empty
            //
            case 101: {       action.builder.
   consumeEmpty();                 break;
            }  
   
            //
            // Rule 102:  delete_expression ::= dcolon_opt delete cast_expression
            //
            case 102: {       action.builder.
   consumeExpressionDelete(false);                 break;
            }  
   
            //
            // Rule 103:  delete_expression ::= dcolon_opt delete [ ] cast_expression
            //
            case 103: {       action.builder.
   consumeExpressionDelete(true);                 break;
            }  
   
            //
            // Rule 105:  cast_expression ::= ( type_id ) cast_expression
            //
            case 105: {       action.builder.
   consumeExpressionCast(ICPPASTCastExpression.op_cast);                 break;
            }  
   
            //
            // Rule 107:  pm_expression ::= pm_expression .* cast_expression
            //
            case 107: {       action.builder.
   consumeExpressionBinaryOperator(ICPPASTBinaryExpression.op_pmdot);                 break;
            }  
   
            //
            // Rule 108:  pm_expression ::= pm_expression ->* cast_expression
            //
            case 108: {       action.builder.
   consumeExpressionBinaryOperator(ICPPASTBinaryExpression.op_pmarrow);                 break;
            }  
   
            //
            // Rule 110:  multiplicative_expression ::= multiplicative_expression * pm_expression
            //
            case 110: {       action.builder.
   consumeExpressionBinaryOperator(ICPPASTBinaryExpression.op_multiply);                 break;
            }  
   
            //
            // Rule 111:  multiplicative_expression ::= multiplicative_expression / pm_expression
            //
            case 111: {       action.builder.
   consumeExpressionBinaryOperator(ICPPASTBinaryExpression.op_divide);                 break;
            }  
   
            //
            // Rule 112:  multiplicative_expression ::= multiplicative_expression % pm_expression
            //
            case 112: {       action.builder.
   consumeExpressionBinaryOperator(ICPPASTBinaryExpression.op_modulo);                 break;
            }  
   
            //
            // Rule 114:  additive_expression ::= additive_expression + multiplicative_expression
            //
            case 114: {       action.builder.
   consumeExpressionBinaryOperator(ICPPASTBinaryExpression.op_plus);                 break;
            }  
   
            //
            // Rule 115:  additive_expression ::= additive_expression - multiplicative_expression
            //
            case 115: {       action.builder.
   consumeExpressionBinaryOperator(ICPPASTBinaryExpression.op_minus);                 break;
            }  
   
            //
            // Rule 117:  shift_expression ::= shift_expression << additive_expression
            //
            case 117: {       action.builder.
   consumeExpressionBinaryOperator(ICPPASTBinaryExpression.op_shiftLeft);                 break;
            }  
   
            //
            // Rule 118:  shift_expression ::= shift_expression >> additive_expression
            //
            case 118: {       action.builder.
   consumeExpressionBinaryOperator(ICPPASTBinaryExpression.op_shiftRight);                 break;
            }  
   
            //
            // Rule 120:  relational_expression ::= relational_expression < shift_expression
            //
            case 120: {       action.builder.
   consumeExpressionBinaryOperator(ICPPASTBinaryExpression.op_lessThan);                 break;
            }  
   
            //
            // Rule 121:  relational_expression ::= relational_expression > shift_expression
            //
            case 121: {       action.builder.
   consumeExpressionBinaryOperator(ICPPASTBinaryExpression.op_greaterThan);                 break;
            }  
   
            //
            // Rule 122:  relational_expression ::= relational_expression <= shift_expression
            //
            case 122: {       action.builder.
   consumeExpressionBinaryOperator(ICPPASTBinaryExpression.op_lessEqual);                 break;
            }  
   
            //
            // Rule 123:  relational_expression ::= relational_expression >= shift_expression
            //
            case 123: {       action.builder.
   consumeExpressionBinaryOperator(ICPPASTBinaryExpression.op_greaterEqual);                 break;
            }  
   
            //
            // Rule 125:  equality_expression ::= equality_expression == relational_expression
            //
            case 125: {       action.builder.
   consumeExpressionBinaryOperator(ICPPASTBinaryExpression.op_equals);                 break;
            }  
   
            //
            // Rule 126:  equality_expression ::= equality_expression != relational_expression
            //
            case 126: {       action.builder.
   consumeExpressionBinaryOperator(ICPPASTBinaryExpression.op_notequals);                 break;
            }  
   
            //
            // Rule 128:  and_expression ::= and_expression & equality_expression
            //
            case 128: {       action.builder.
   consumeExpressionBinaryOperator(ICPPASTBinaryExpression.op_binaryAnd);                 break;
            }  
   
            //
            // Rule 130:  exclusive_or_expression ::= exclusive_or_expression ^ and_expression
            //
            case 130: {       action.builder.
   consumeExpressionBinaryOperator(ICPPASTBinaryExpression.op_binaryXor);                 break;
            }  
   
            //
            // Rule 132:  inclusive_or_expression ::= inclusive_or_expression | exclusive_or_expression
            //
            case 132: {       action.builder.
   consumeExpressionBinaryOperator(ICPPASTBinaryExpression.op_binaryOr);                 break;
            }  
   
            //
            // Rule 134:  logical_and_expression ::= logical_and_expression && inclusive_or_expression
            //
            case 134: {       action.builder.
   consumeExpressionBinaryOperator(ICPPASTBinaryExpression.op_logicalAnd);                 break;
            }  
   
            //
            // Rule 136:  logical_or_expression ::= logical_or_expression || logical_and_expression
            //
            case 136: {       action.builder.
   consumeExpressionBinaryOperator(ICPPASTBinaryExpression.op_logicalOr);                 break;
            }  
   
            //
            // Rule 138:  conditional_expression ::= logical_or_expression ? expression : assignment_expression
            //
            case 138: {       action.builder.
   consumeExpressionConditional();                 break;
            }  
   
            //
            // Rule 139:  throw_expression ::= throw
            //
            case 139: {       action.builder.
   consumeExpressionThrow(false);                 break;
            }  
   
            //
            // Rule 140:  throw_expression ::= throw assignment_expression
            //
            case 140: {       action.builder.
   consumeExpressionThrow(true);                 break;
            }  
   
            //
            // Rule 143:  assignment_expression ::= logical_or_expression = assignment_expression
            //
            case 143: {       action.builder.
   consumeExpressionBinaryOperator(ICPPASTBinaryExpression.op_assign);                 break;
            }  
   
            //
            // Rule 144:  assignment_expression ::= logical_or_expression *= assignment_expression
            //
            case 144: {       action.builder.
   consumeExpressionBinaryOperator(ICPPASTBinaryExpression.op_multiplyAssign);                 break;
            }  
   
            //
            // Rule 145:  assignment_expression ::= logical_or_expression /= assignment_expression
            //
            case 145: {       action.builder.
   consumeExpressionBinaryOperator(ICPPASTBinaryExpression.op_divideAssign);                 break;
            }  
   
            //
            // Rule 146:  assignment_expression ::= logical_or_expression %= assignment_expression
            //
            case 146: {       action.builder.
   consumeExpressionBinaryOperator(ICPPASTBinaryExpression.op_moduloAssign);                 break;
            }  
   
            //
            // Rule 147:  assignment_expression ::= logical_or_expression += assignment_expression
            //
            case 147: {       action.builder.
   consumeExpressionBinaryOperator(ICPPASTBinaryExpression.op_plusAssign);                 break;
            }  
   
            //
            // Rule 148:  assignment_expression ::= logical_or_expression -= assignment_expression
            //
            case 148: {       action.builder.
   consumeExpressionBinaryOperator(ICPPASTBinaryExpression.op_minusAssign);                 break;
            }  
   
            //
            // Rule 149:  assignment_expression ::= logical_or_expression >>= assignment_expression
            //
            case 149: {       action.builder.
   consumeExpressionBinaryOperator(ICPPASTBinaryExpression.op_shiftRightAssign);                 break;
            }  
   
            //
            // Rule 150:  assignment_expression ::= logical_or_expression <<= assignment_expression
            //
            case 150: {       action.builder.
   consumeExpressionBinaryOperator(ICPPASTBinaryExpression.op_shiftLeftAssign);                 break;
            }  
   
            //
            // Rule 151:  assignment_expression ::= logical_or_expression &= assignment_expression
            //
            case 151: {       action.builder.
   consumeExpressionBinaryOperator(ICPPASTBinaryExpression.op_binaryAndAssign);                 break;
            }  
   
            //
            // Rule 152:  assignment_expression ::= logical_or_expression ^= assignment_expression
            //
            case 152: {       action.builder.
   consumeExpressionBinaryOperator(ICPPASTBinaryExpression.op_binaryXorAssign);                 break;
            }  
   
            //
            // Rule 153:  assignment_expression ::= logical_or_expression |= assignment_expression
            //
            case 153: {       action.builder.
   consumeExpressionBinaryOperator(ICPPASTBinaryExpression.op_binaryOrAssign);                 break;
            }  
   
            //
            // Rule 155:  expression ::= ERROR_TOKEN
            //
            case 155: {       action.builder.
   consumeExpressionProblem();                break;
            }  
   
            //
            // Rule 156:  expression_list ::= <openscope-ast> expression_list_actual
            //
            case 156: {       action.builder.
   consumeExpressionList();                 break;
            }  
   
            //
            // Rule 160:  expression_list_opt ::= $Empty
            //
            case 160: {       action.builder.
   consumeEmpty();                 break;
            }  
   
            //
            // Rule 162:  expression_opt ::= $Empty
            //
            case 162: {       action.builder.
   consumeEmpty();                 break;
            }  
   
            //
            // Rule 165:  constant_expression_opt ::= $Empty
            //
            case 165: {       action.builder.
   consumeEmpty();                 break;
            }  
   
            //
            // Rule 174:  statement ::= ERROR_TOKEN
            //
            case 174: {       action.builder.
   consumeStatementProblem();                 break;
            }  
   
            //
            // Rule 175:  labeled_statement ::= identifier : statement
            //
            case 175: {       action.builder.
   consumeStatementLabeled();                 break;
            }  
   
            //
            // Rule 176:  labeled_statement ::= case constant_expression :
            //
            case 176: {       action.builder.
   consumeStatementCase();                 break;
            }  
   
            //
            // Rule 177:  labeled_statement ::= default :
            //
            case 177: {       action.builder.
   consumeStatementDefault();                 break;
            }  
   
            //
            // Rule 178:  expression_statement ::= expression ;
            //
            case 178: {       action.builder.
   consumeStatementExpression();                 break;
            }  
   
            //
            // Rule 179:  expression_statement ::= ;
            //
            case 179: {       action.builder.
   consumeStatementNull();                 break;
            }  
   
            //
            // Rule 180:  compound_statement ::= { <openscope-ast> statement_seq }
            //
            case 180: {       action.builder.
   consumeStatementCompoundStatement(true);                 break;
            }  
   
            //
            // Rule 181:  compound_statement ::= { }
            //
            case 181: {       action.builder.
   consumeStatementCompoundStatement(false);                 break;
            }  
   
            //
            // Rule 184:  selection_statement ::= if ( condition ) statement
            //
            case 184: {       action.builder.
   consumeStatementIf(false);                 break;
            }  
   
            //
            // Rule 185:  selection_statement ::= if ( condition ) statement else statement
            //
            case 185: {       action.builder.
   consumeStatementIf(true);                 break;
            }  
   
            //
            // Rule 186:  selection_statement ::= switch ( condition ) statement
            //
            case 186: {       action.builder.
   consumeStatementSwitch();                 break;
            }  
   
            //
            // Rule 188:  condition ::= type_specifier_seq declarator = assignment_expression
            //
            case 188: {       action.builder.
   consumeConditionDeclaration();                 break;
            }  
   
            //
            // Rule 189:  iteration_statement ::= while ( condition ) statement
            //
            case 189: {       action.builder.
   consumeStatementWhileLoop();                 break;
            }  
   
            //
            // Rule 190:  iteration_statement ::= do statement while ( expression ) ;
            //
            case 190: {       action.builder.
   consumeStatementDoLoop();                 break;
            }  
   
            //
            // Rule 191:  iteration_statement ::= for ( expression_opt ; expression_opt ; expression_opt ) statement
            //
            case 191: {       action.builder.
  consumeStatementForLoop();                break;
            }  
   
            //
            // Rule 192:  iteration_statement ::= for ( simple_declaration expression_opt ; expression_opt ) statement
            //
            case 192: {       action.builder.
  consumeStatementForLoop();                break;
            }  
   
            //
            // Rule 193:  jump_statement ::= break ;
            //
            case 193: {       action.builder.
   consumeStatementBreak();                 break;
            }  
   
            //
            // Rule 194:  jump_statement ::= continue ;
            //
            case 194: {       action.builder.
   consumeStatementContinue();                 break;
            }  
   
            //
            // Rule 195:  jump_statement ::= return expression ;
            //
            case 195: {       action.builder.
   consumeStatementReturn(true);                 break;
            }  
   
            //
            // Rule 196:  jump_statement ::= return ;
            //
            case 196: {       action.builder.
   consumeStatementReturn(false);                 break;
            }  
   
            //
            // Rule 197:  jump_statement ::= goto identifier ;
            //
            case 197: {       action.builder.
   consumeStatementGoto();                 break;
            }  
   
            //
            // Rule 198:  declaration_statement ::= block_declaration
            //
            case 198: {       action.builder.
   consumeStatementDeclaration();                 break;
            }  
   
            //
            // Rule 215:  simple_declaration ::= declaration_specifiers_opt <openscope-ast> init_declarator_list_opt ;
            //
            case 215: {       action.builder.
   consumeDeclarationSimple(true);                 break;
            }  
   
            //
            // Rule 216:  declaration_specifiers ::= <openscope-ast> simple_declaration_specifiers
            //
            case 216: {       action.builder.
   consumeDeclarationSpecifiersSimple();                 break;
            }  
   
            //
            // Rule 217:  declaration_specifiers ::= <openscope-ast> class_declaration_specifiers
            //
            case 217: {       action.builder.
   consumeDeclarationSpecifiersComposite();                 break;
            }  
   
            //
            // Rule 218:  declaration_specifiers ::= <openscope-ast> elaborated_declaration_specifiers
            //
            case 218: {       action.builder.
   consumeDeclarationSpecifiersComposite();                 break;
            }  
   
            //
            // Rule 219:  declaration_specifiers ::= <openscope-ast> enum_declaration_specifiers
            //
            case 219: {       action.builder.
   consumeDeclarationSpecifiersComposite();                 break;
            }  
   
            //
            // Rule 220:  declaration_specifiers ::= <openscope-ast> type_name_declaration_specifiers
            //
            case 220: {       action.builder.
   consumeDeclarationSpecifiersTypeName();                 break;
            }  
   
            //
            // Rule 222:  declaration_specifiers_opt ::= $Empty
            //
            case 222: {       action.builder.
   consumeEmpty();                 break;
            }  
   
            //
            // Rule 226:  no_type_declaration_specifier ::= friend
            //
            case 226: {       action.builder.
   consumeDeclSpecToken();                break;
            }  
   
            //
            // Rule 227:  no_type_declaration_specifier ::= typedef
            //
            case 227: {       action.builder.
   consumeDeclSpecToken();                break;
            }  
   
            //
            // Rule 255:  simple_type_specifier ::= simple_type_specifier_token
            //
            case 255: {       action.builder.
   consumeDeclSpecToken();                break;
            }  
   
            //
            // Rule 271:  type_name_specifier ::= dcolon_opt nested_name_specifier_opt type_name
            //
            case 271: {       action.builder.
   consumeQualifiedId(false);                 break;
            }  
   
            //
            // Rule 272:  type_name_specifier ::= dcolon_opt nested_name_specifier template template_id_name
            //
            case 272: {       action.builder.
   consumeQualifiedId(false);                 break;
            }  
   
            //
            // Rule 273:  type_name_specifier ::= typename dcolon_opt nested_name_specifier identifier_name
            //
            case 273: {       action.builder.
   consumeQualifiedId(false);                 break;
            }  
   
            //
            // Rule 274:  type_name_specifier ::= typename dcolon_opt nested_name_specifier template_opt template_id_name
            //
            case 274: {       action.builder.
   consumeQualifiedId(true);                 break;
            }  
   
            //
            // Rule 275:  elaborated_type_specifier ::= class_keyword dcolon_opt nested_name_specifier_opt identifier_name
            //
            case 275: {       action.builder.
   consumeTypeSpecifierElaborated(false);                 break;
            }  
   
            //
            // Rule 276:  elaborated_type_specifier ::= class_keyword dcolon_opt nested_name_specifier_opt template_opt template_id_name
            //
            case 276: {       action.builder.
   consumeTypeSpecifierElaborated(true);                  break;
            }  
   
            //
            // Rule 277:  elaborated_type_specifier ::= enum dcolon_opt nested_name_specifier_opt identifier_name
            //
            case 277: {       action.builder.
   consumeTypeSpecifierElaborated(false);                 break;
            }  
   
            //
            // Rule 279:  enum_specifier ::= enum { <openscope-ast> enumerator_list_opt }
            //
            case 279: {       action.builder.
   consumeTypeSpecifierEnumeration(false);                break;
            }  
   
            //
            // Rule 280:  enum_specifier ::= enum identifier { <openscope-ast> enumerator_list_opt }
            //
            case 280: {       action.builder.
   consumeTypeSpecifierEnumeration(true);                break;
            }  
   
            //
            // Rule 285:  enumerator_definition ::= enumerator
            //
            case 285: {       action.builder.
   consumeEnumerator(false);                break;
            }  
   
            //
            // Rule 286:  enumerator_definition ::= enumerator = constant_expression
            //
            case 286: {       action.builder.
   consumeEnumerator(true);                break;
            }  
   
            //
            // Rule 295:  original_namespace_definition ::= namespace identifier_name { <openscope-ast> declaration_seq_opt }
            //
            case 295: {       action.builder.
   consumeNamespaceDefinition(true);                 break;
            }  
   
            //
            // Rule 296:  extension_namespace_definition ::= namespace original_namespace_name { <openscope-ast> declaration_seq_opt }
            //
            case 296: {       action.builder.
   consumeNamespaceDefinition(true);                 break;
            }  
   
            //
            // Rule 297:  unnamed_namespace_definition ::= namespace { <openscope-ast> declaration_seq_opt }
            //
            case 297: {       action.builder.
   consumeNamespaceDefinition(false);                 break;
            }  
   
            //
            // Rule 299:  namespace_alias_definition ::= namespace identifier = dcolon_opt nested_name_specifier_opt namespace_name ;
            //
            case 299: {       action.builder.
   consumeNamespaceAliasDefinition();                break;
            }  
   
            //
            // Rule 300:  using_declaration ::= using typename_opt dcolon_opt nested_name_specifier_opt unqualified_id_name ;
            //
            case 300: {       action.builder.
   consumeUsingDeclaration();                 break;
            }  
   
            //
            // Rule 301:  typename_opt ::= typename
            //
            case 301: {       action.builder.
   consumePlaceHolder();                 break;
            }  
   
            //
            // Rule 302:  typename_opt ::= $Empty
            //
            case 302: {       action.builder.
   consumeEmpty();                 break;
            }  
   
            //
            // Rule 303:  using_directive ::= using namespace dcolon_opt nested_name_specifier_opt namespace_name ;
            //
            case 303: {       action.builder.
   consumeUsingDirective();                 break;
            }  
   
            //
            // Rule 304:  asm_definition ::= asm ( stringlit ) ;
            //
            case 304: {       action.builder.
   consumeDeclarationASM();                break;
            }  
   
            //
            // Rule 305:  linkage_specification ::= extern stringlit { <openscope-ast> declaration_seq_opt }
            //
            case 305: {       action.builder.
   consumeLinkageSpecification();                 break;
            }  
   
            //
            // Rule 306:  linkage_specification ::= extern stringlit <openscope-ast> declaration
            //
            case 306: {       action.builder.
   consumeLinkageSpecification();                 break;
            }  
   
            //
            // Rule 312:  init_declarator ::= declarator initializer
            //
            case 312: {       action.builder.
   consumeDeclaratorWithInitializer(true);                 break;
            }  
   
            //
            // Rule 314:  declarator ::= <openscope-ast> ptr_operator_seq direct_declarator
            //
            case 314: {       action.builder.
   consumeDeclaratorWithPointer(true);                 break;
            }  
   
            //
            // Rule 318:  basic_direct_declarator ::= declarator_id_name
            //
            case 318: {       action.builder.
   consumeDirectDeclaratorIdentifier();                 break;
            }  
   
            //
            // Rule 319:  basic_direct_declarator ::= ( declarator )
            //
            case 319: {       action.builder.
   consumeDirectDeclaratorBracketed();                 break;
            }  
   
            //
            // Rule 320:  function_direct_declarator ::= basic_direct_declarator ( <openscope-ast> parameter_declaration_clause ) <openscope-ast> cv_qualifier_seq_opt <openscope-ast> exception_specification_opt
            //
            case 320: {       action.builder.
   consumeDirectDeclaratorFunctionDeclarator(true);                 break;
            }  
   
            //
            // Rule 321:  array_direct_declarator ::= array_direct_declarator array_modifier
            //
            case 321: {       action.builder.
   consumeDirectDeclaratorArrayDeclarator(true);                 break;
            }  
   
            //
            // Rule 322:  array_direct_declarator ::= basic_direct_declarator array_modifier
            //
            case 322: {       action.builder.
   consumeDirectDeclaratorArrayDeclarator(true);                 break;
            }  
   
            //
            // Rule 323:  array_modifier ::= [ constant_expression ]
            //
            case 323: {       action.builder.
   consumeDirectDeclaratorArrayModifier(true);                 break;
            }  
   
            //
            // Rule 324:  array_modifier ::= [ ]
            //
            case 324: {       action.builder.
   consumeDirectDeclaratorArrayModifier(false);                 break;
            }  
   
            //
            // Rule 325:  ptr_operator ::= * <openscope-ast> cv_qualifier_seq_opt
            //
            case 325: {       action.builder.
   consumePointer();                 break;
            }  
   
            //
            // Rule 326:  ptr_operator ::= &
            //
            case 326: {       action.builder.
   consumeReferenceOperator();                 break;
            }  
   
            //
            // Rule 327:  ptr_operator ::= dcolon_opt nested_name_specifier * <openscope-ast> cv_qualifier_seq_opt
            //
            case 327: {       action.builder.
   consumePointerToMember();                 break;
            }  
   
            //
            // Rule 333:  cv_qualifier ::= const
            //
            case 333: {       action.builder.
   consumeDeclSpecToken();                break;
            }  
   
            //
            // Rule 334:  cv_qualifier ::= volatile
            //
            case 334: {       action.builder.
   consumeDeclSpecToken();                break;
            }  
   
            //
            // Rule 336:  declarator_id_name ::= dcolon_opt nested_name_specifier_opt type_name
            //
            case 336: {       action.builder.
   consumeQualifiedId(false);                 break;
            }  
   
            //
            // Rule 337:  type_id ::= type_specifier_seq
            //
            case 337: {       action.builder.
   consumeTypeId(false);                 break;
            }  
   
            //
            // Rule 338:  type_id ::= type_specifier_seq abstract_declarator
            //
            case 338: {       action.builder.
   consumeTypeId(true);                 break;
            }  
   
            //
            // Rule 341:  abstract_declarator ::= <openscope-ast> ptr_operator_seq
            //
            case 341: {       action.builder.
   consumeDeclaratorWithPointer(false);                 break;
            }  
   
            //
            // Rule 342:  abstract_declarator ::= <openscope-ast> ptr_operator_seq direct_abstract_declarator
            //
            case 342: {       action.builder.
   consumeDeclaratorWithPointer(true);                 break;
            }  
   
            //
            // Rule 346:  basic_direct_abstract_declarator ::= ( abstract_declarator )
            //
            case 346: {       action.builder.
   consumeDirectDeclaratorBracketed();                 break;
            }  
   
            //
            // Rule 347:  array_direct_abstract_declarator ::= array_modifier
            //
            case 347: {       action.builder.
   consumeDirectDeclaratorArrayDeclarator(false);                 break;
            }  
   
            //
            // Rule 348:  array_direct_abstract_declarator ::= array_direct_abstract_declarator array_modifier
            //
            case 348: {       action.builder.
   consumeDirectDeclaratorArrayDeclarator(true);                 break;
            }  
   
            //
            // Rule 349:  array_direct_abstract_declarator ::= basic_direct_abstract_declarator array_modifier
            //
            case 349: {       action.builder.
   consumeDirectDeclaratorArrayDeclarator(true);                 break;
            }  
   
            //
            // Rule 350:  function_direct_abstract_declarator ::= basic_direct_abstract_declarator ( <openscope-ast> parameter_declaration_clause ) <openscope-ast> cv_qualifier_seq_opt <openscope-ast> exception_specification_opt
            //
            case 350: {       action.builder.
   consumeDirectDeclaratorFunctionDeclarator(true);                 break;
            }  
   
            //
            // Rule 351:  function_direct_abstract_declarator ::= ( <openscope-ast> parameter_declaration_clause ) <openscope-ast> cv_qualifier_seq_opt <openscope-ast> exception_specification_opt
            //
            case 351: {       action.builder.
   consumeDirectDeclaratorFunctionDeclarator(false);                 break;
            }  
   
            //
            // Rule 352:  parameter_declaration_clause ::= parameter_declaration_list_opt ...
            //
            case 352: {       action.builder.
   consumePlaceHolder();                 break;
            }  
   
            //
            // Rule 353:  parameter_declaration_clause ::= parameter_declaration_list_opt
            //
            case 353: {       action.builder.
   consumeEmpty();                 break;
            }  
   
            //
            // Rule 354:  parameter_declaration_clause ::= parameter_declaration_list , ...
            //
            case 354: {       action.builder.
   consumePlaceHolder();                 break;
            }  
   
            //
            // Rule 360:  abstract_declarator_opt ::= $Empty
            //
            case 360: {       action.builder.
   consumeEmpty();                 break;
            }  
   
            //
            // Rule 361:  parameter_declaration ::= declaration_specifiers parameter_init_declarator
            //
            case 361: {       action.builder.
   consumeParameterDeclaration();                 break;
            }  
   
            //
            // Rule 362:  parameter_declaration ::= declaration_specifiers
            //
            case 362: {       action.builder.
   consumeParameterDeclarationWithoutDeclarator();                 break;
            }  
   
            //
            // Rule 364:  parameter_init_declarator ::= declarator = parameter_initializer
            //
            case 364: {       action.builder.
   consumeDeclaratorWithInitializer(true);                 break;
            }  
   
            //
            // Rule 366:  parameter_init_declarator ::= abstract_declarator = parameter_initializer
            //
            case 366: {       action.builder.
   consumeDeclaratorWithInitializer(true);                 break;
            }  
   
            //
            // Rule 367:  parameter_init_declarator ::= = parameter_initializer
            //
            case 367: {       action.builder.
   consumeDeclaratorWithInitializer(false);                 break;
            }  
   
            //
            // Rule 368:  parameter_initializer ::= assignment_expression
            //
            case 368: {       action.builder.
   consumeInitializer();                 break;
            }  
   
            //
            // Rule 369:  function_definition ::= declaration_specifiers_opt function_direct_declarator <openscope-ast> ctor_initializer_list_opt function_body
            //
            case 369: {       action.builder.
   consumeFunctionDefinition(false);                 break;
            }  
   
            //
            // Rule 370:  function_definition ::= declaration_specifiers_opt function_direct_declarator try <openscope-ast> ctor_initializer_list_opt function_body <openscope-ast> handler_seq
            //
            case 370: {       action.builder.
   consumeFunctionDefinition(true);                 break;
            }  
   
            //
            // Rule 373:  initializer ::= ( expression_list )
            //
            case 373: {       action.builder.
   consumeInitializerConstructor();                 break;
            }  
   
            //
            // Rule 374:  initializer_clause ::= assignment_expression
            //
            case 374: {       action.builder.
   consumeInitializer();                 break;
            }  
   
            //
            // Rule 375:  initializer_clause ::= { <openscope-ast> initializer_list , }
            //
            case 375: {       action.builder.
   consumeInitializerList();                 break;
            }  
   
            //
            // Rule 376:  initializer_clause ::= { <openscope-ast> initializer_list }
            //
            case 376: {       action.builder.
   consumeInitializerList();                 break;
            }  
   
            //
            // Rule 377:  initializer_clause ::= { <openscope-ast> }
            //
            case 377: {       action.builder.
   consumeInitializerList();                 break;
            }  
   
            //
            // Rule 382:  class_specifier ::= class_head { <openscope-ast> member_declaration_list_opt }
            //
            case 382: {       action.builder.
   consumeClassSpecifier();                 break;
            }  
   
            //
            // Rule 383:  class_head ::= class_keyword identifier_name_opt <openscope-ast> base_clause_opt
            //
            case 383: {       action.builder.
   consumeClassHead(false);                 break;
            }  
   
            //
            // Rule 384:  class_head ::= class_keyword template_id_name <openscope-ast> base_clause_opt
            //
            case 384: {       action.builder.
   consumeClassHead(false);                 break;
            }  
   
            //
            // Rule 385:  class_head ::= class_keyword nested_name_specifier identifier_name <openscope-ast> base_clause_opt
            //
            case 385: {       action.builder.
   consumeClassHead(true);                 break;
            }  
   
            //
            // Rule 386:  class_head ::= class_keyword nested_name_specifier template_id_name <openscope-ast> base_clause_opt
            //
            case 386: {       action.builder.
   consumeClassHead(true);                 break;
            }  
   
            //
            // Rule 390:  identifier_name_opt ::= $Empty
            //
            case 390: {       action.builder.
   consumeEmpty();                 break;
            } 
   
            //
            // Rule 394:  visibility_label ::= access_specifier_keyword :
            //
            case 394: {       action.builder.
   consumeVisibilityLabel();                 break;
            }  
   
            //
            // Rule 395:  member_declaration ::= declaration_specifiers_opt <openscope-ast> member_declarator_list ;
            //
            case 395: {       action.builder.
   consumeDeclarationSimple(true);                 break;
            }  
   
            //
            // Rule 396:  member_declaration ::= declaration_specifiers_opt ;
            //
            case 396: {       action.builder.
   consumeDeclarationSimple(false);                 break;
            }  
   
            //
            // Rule 399:  member_declaration ::= dcolon_opt nested_name_specifier template_opt unqualified_id_name ;
            //
            case 399: {       action.builder.
   consumeMemberDeclarationQualifiedId();                 break;
            }  
   
            //
            // Rule 410:  member_declarator ::= declarator constant_initializer
            //
            case 410: {       action.builder.
   consumeMemberDeclaratorWithInitializer();                 break;
            }  
   
            //
            // Rule 411:  member_declarator ::= bit_field_declarator : constant_expression
            //
            case 411: {       action.builder.
   consumeBitField(true);                 break;
            }  
   
            //
            // Rule 412:  member_declarator ::= : constant_expression
            //
            case 412: {       action.builder.
   consumeBitField(false);                 break;
            }  
   
            //
            // Rule 413:  bit_field_declarator ::= identifier_name
            //
            case 413: {       action.builder.
   consumeDirectDeclaratorIdentifier();                 break;
            }  
   
            //
            // Rule 420:  base_specifier ::= dcolon_opt nested_name_specifier_opt class_name
            //
            case 420: {       action.builder.
   consumeBaseSpecifier(false);                 break;
            }  
   
            //
            // Rule 421:  base_specifier ::= virtual_opt access_specifier_keyword virtual_opt dcolon_opt nested_name_specifier_opt class_name
            //
            case 421: {       action.builder.
   consumeBaseSpecifier(true);                 break;
            }  
   
            //
            // Rule 422:  virtual_opt ::= virtual
            //
            case 422: {       action.builder.
   consumePlaceHolder();                 break;
            }  
   
            //
            // Rule 423:  virtual_opt ::= $Empty
            //
            case 423: {       action.builder.
   consumeEmpty();                 break;
            }  
   
            //
            // Rule 429:  conversion_function_id_name ::= operator conversion_type_id
            //
            case 429: {       action.builder.
   consumeConversionName();                break;
            }  
   
            //
            // Rule 430:  conversion_type_id ::= type_specifier_seq conversion_declarator
            //
            case 430: {       action.builder.
   consumeTypeId(true);                 break;
            }  
   
            //
            // Rule 431:  conversion_type_id ::= type_specifier_seq
            //
            case 431: {       action.builder.
   consumeTypeId(false);                 break;
            }  
   
            //
            // Rule 432:  conversion_declarator ::= <openscope-ast> ptr_operator_seq
            //
            case 432: {       action.builder.
   consumeDeclaratorWithPointer(false);                 break;
            }  
   
            //
            // Rule 438:  mem_initializer ::= mem_initializer_name ( expression_list_opt )
            //
            case 438: {       action.builder.
   consumeConstructorChainInitializer();                 break;
            }  
   
            //
            // Rule 439:  mem_initializer_name ::= dcolon_opt nested_name_specifier_opt class_name
            //
            case 439: {       action.builder.
   consumeQualifiedId(false);                 break;
            }  
   
            //
            // Rule 442:  operator_function_id_name ::= operator_id_name < <openscope-ast> template_argument_list_opt >
            //
            case 442: {       action.builder.
   consumeTemplateId();                 break;
            }  
   
            //
            // Rule 443:  operator_id_name ::= operator overloadable_operator
            //
            case 443: {       action.builder.
   consumeOperatorName();                 break;
            }  
   
            //
            // Rule 486:  template_declaration ::= export_opt template < <openscope-ast> template_parameter_list > declaration
            //
            case 486: {       action.builder.
   consumeTemplateDeclaration();                 break;
            }  
   
            //
            // Rule 487:  export_opt ::= export
            //
            case 487: {       action.builder.
   consumePlaceHolder();                 break;
            }  
   
            //
            // Rule 488:  export_opt ::= $Empty
            //
            case 488: {       action.builder.
   consumeEmpty();                 break;
            }  
   
            //
            // Rule 493:  type_parameter ::= class identifier_name_opt
            //
            case 493: {       action.builder.
   consumeSimpleTypeTemplateParameter(false);                 break;
            }  
   
            //
            // Rule 494:  type_parameter ::= class identifier_name_opt = type_id
            //
            case 494: {       action.builder.
   consumeSimpleTypeTemplateParameter(true);                 break;
            }  
   
            //
            // Rule 495:  type_parameter ::= typename identifier_name_opt
            //
            case 495: {       action.builder.
   consumeSimpleTypeTemplateParameter(false);                 break;
            }  
   
            //
            // Rule 496:  type_parameter ::= typename identifier_name_opt = type_id
            //
            case 496: {       action.builder.
   consumeSimpleTypeTemplateParameter(true);                 break;
            }  
   
            //
            // Rule 497:  type_parameter ::= template < <openscope-ast> template_parameter_list > class identifier_name_opt
            //
            case 497: {       action.builder.
   consumeTemplatedTypeTemplateParameter(false);                 break;
            }  
   
            //
            // Rule 498:  type_parameter ::= template < <openscope-ast> template_parameter_list > class identifier_name_opt = id_expression
            //
            case 498: {       action.builder.
   consumeTemplatedTypeTemplateParameter(true);                 break;
            }  
   
            //
            // Rule 499:  template_id_name ::= template_identifier < <openscope-ast> template_argument_list_opt >
            //
            case 499: {       action.builder.
   consumeTemplateId();                 break;
            }  
   
            //
            // Rule 508:  explicit_instantiation ::= template declaration
            //
            case 508: {       action.builder.
   consumeTemplateExplicitInstantiation();                 break;
            }  
   
            //
            // Rule 509:  explicit_specialization ::= template < > declaration
            //
            case 509: {       action.builder.
   consumeTemplateExplicitSpecialization();                 break;
            }  
   
            //
            // Rule 510:  try_block ::= try compound_statement <openscope-ast> handler_seq
            //
            case 510: {       action.builder.
   consumeStatementTryBlock();                 break;
            }  
   
            //
            // Rule 513:  handler ::= catch ( exception_declaration ) compound_statement
            //
            case 513: {       action.builder.
   consumeStatementCatchHandler(false);                 break;
            }  
   
            //
            // Rule 514:  handler ::= catch ( ... ) compound_statement
            //
            case 514: {       action.builder.
   consumeStatementCatchHandler(true);                 break;
            }  
   
            //
            // Rule 515:  exception_declaration ::= type_specifier_seq <openscope-ast> declarator
            //
            case 515: {       action.builder.
   consumeDeclarationSimple(true);                 break;
            }  
   
            //
            // Rule 516:  exception_declaration ::= type_specifier_seq <openscope-ast> abstract_declarator
            //
            case 516: {       action.builder.
   consumeDeclarationSimple(true);                 break;
            }  
   
            //
            // Rule 517:  exception_declaration ::= type_specifier_seq
            //
            case 517: {       action.builder.
   consumeDeclarationSimple(false);                 break;
            }  

    
            default:
                break;
        }
        return;
    }
}

