/*******************************************************************************
* Copyright (c) 2006, 2007 IBM Corporation and others.
* All rights reserved. This program and the accompanying materials
* are made available under the terms of the Eclipse Public License v1.0
* which accompanies this distribution, and is available at
* http://www.eclipse.org/legal/epl-v10.html
*
* Contributors:
*     IBM Corporation - initial API and implementation
*********************************************************************************/

// This file was generated by LPG

package org.eclipse.cdt.internal.core.dom.parser.c99;

import lpg.lpgjavaruntime.*;

import org.eclipse.cdt.core.dom.ast.*;
import org.eclipse.cdt.core.dom.c99.IPreprocessorTokenOuput;
import org.eclipse.cdt.internal.core.parser.scanner2.ILocationResolver;
import org.eclipse.cdt.core.index.IIndex;
import org.eclipse.cdt.core.dom.ast.IASTCompletionNode;

public class C99Parser extends PrsStream implements RuleAction , IPreprocessorTokenOuput 
{
    private static ParseTable prs = new C99Parserprs();
    private BacktrackingParser btParser;

    public BacktrackingParser getParser() { return btParser; }
    private void setResult(Object object) { btParser.setSym1(object); }
    public Object getRhsSym(int i) { return btParser.getSym(i); }

    public int getRhsTokenIndex(int i) { return btParser.getToken(i); }
    public IToken getRhsIToken(int i) { return super.getIToken(getRhsTokenIndex(i)); }
    
    public int getRhsFirstTokenIndex(int i) { return btParser.getFirstToken(i); }
    public IToken getRhsFirstIToken(int i) { return super.getIToken(getRhsFirstTokenIndex(i)); }

    public int getRhsLastTokenIndex(int i) { return btParser.getLastToken(i); }
    public IToken getRhsLastIToken(int i) { return super.getIToken(getRhsLastTokenIndex(i)); }

    public int getLeftSpan() { return btParser.getFirstToken(); }
    public IToken getLeftIToken()  { return super.getIToken(getLeftSpan()); }

    public int getRightSpan() { return btParser.getLastToken(); }
    public IToken getRightIToken() { return super.getIToken(getRightSpan()); }

    public int getRhsErrorTokenIndex(int i)
    {
        int index = btParser.getToken(i);
        IToken err = super.getIToken(index);
        return (err instanceof ErrorToken ? index : 0);
    }
    public ErrorToken getRhsErrorIToken(int i)
    {
        int index = btParser.getToken(i);
        IToken err = super.getIToken(index);
        return (ErrorToken) (err instanceof ErrorToken ? err : null);
    }

    public C99Parser(LexStream lexStream)
    {
        super(lexStream);

        try
        {
            super.remapTerminalSymbols(orderedTerminalSymbols(), C99Parserprs.EOFT_SYMBOL);
        }
        catch(NullExportedSymbolsException e) {
        }
        catch(NullTerminalSymbolsException e) {
        }
        catch(UnimplementedTerminalsException e)
        {
            java.util.ArrayList unimplemented_symbols = e.getSymbols();
            System.out.println(Messages.getString("C99Parser.0")); //$NON-NLS-1$
            for (int i = 0; i < unimplemented_symbols.size(); i++)
            {
                Integer id = (Integer) unimplemented_symbols.get(i);
                System.out.println("    " + C99Parsersym.orderedTerminalSymbols[id.intValue()]);                //$NON-NLS-1$
            }
            System.out.println();                        
        }
        catch(UndefinedEofSymbolException e)
        {
            throw new Error(new UndefinedEofSymbolException
                                (Messages.getString("C99Parser.1") + //$NON-NLS-1$
                                 C99Parsersym.orderedTerminalSymbols[C99Parserprs.EOFT_SYMBOL]));
        } 
    }

    public String[] orderedTerminalSymbols() { return C99Parsersym.orderedTerminalSymbols; }
    public String getTokenKindName(int kind) { return C99Parsersym.orderedTerminalSymbols[kind]; }
    public int getEOFTokenKind() { return C99Parserprs.EOFT_SYMBOL; }
    public PrsStream getParseStream() { return (PrsStream) this; }
    
    //
    // Report error message for given error_token.
    //
    public final void reportErrorTokenMessage(int error_token, String msg)
    {
        int firsttok = super.getFirstErrorToken(error_token),
            lasttok = super.getLastErrorToken(error_token);
        String location = super.getFileName() + ':' +
                          (firsttok > lasttok
                                    ? (super.getEndLine(lasttok) + ":" + super.getEndColumn(lasttok)) //$NON-NLS-1$
                                    : (super.getLine(error_token) + ":" + //$NON-NLS-1$
                                       super.getColumn(error_token) + ":" + //$NON-NLS-1$
                                       super.getEndLine(error_token) + ":" + //$NON-NLS-1$
                                       super.getEndColumn(error_token)))
                          + ": "; //$NON-NLS-1$
        super.reportError((firsttok > lasttok ? ParseErrorCodes.INSERTION_CODE : ParseErrorCodes.SUBSTITUTION_CODE), location, msg);
    }

    public Object parser()
    {
        return parser(null, 0);
    }
    
    public Object parser(Monitor monitor)
    {
        return parser(monitor, 0);
    }
    
    public Object parser(int error_repair_count)
    {
        return parser(null, error_repair_count);
    }

    public Object parser(Monitor monitor, int error_repair_count)
    {
        try
        {
            btParser = new BacktrackingParser(monitor, (TokenStream) this, prs, (RuleAction) this);
        }
        catch (NotBacktrackParseTableException e)
        {
            throw new Error(new NotBacktrackParseTableException
                                (Messages.getString("C99Parser.2"))); //$NON-NLS-1$
        }
        catch (BadParseSymFileException e)
        {
            throw new Error(new BadParseSymFileException(Messages.getString("C99Parser.3"))); //$NON-NLS-1$
        }

        try
        {
            return (Object) btParser.parse(error_repair_count);
        }
        catch (BadParseException e)
        {
            reset(e.error_token); // point to error token
            DiagnoseParser diagnoseParser = new DiagnoseParser(this, prs);
            diagnoseParser.diagnose(e.error_token);
        }

        return null;
    }


private C99ParserAction action = new C99ParserAction(this);

public C99Parser() {}

public IASTTranslationUnit parse(ILocationResolver resolver, IIndex index) {
	action.setResolver(resolver);
	action.setIndex(index);
	parser(null, -1);
	return action.getAST();
}

public void prepareToParse() {
	// this has to be done, or... kaboom!
	setStreamLength(getSize());
}

public boolean encounteredError() {
	return action.encounteredError();
}

public IASTCompletionNode getASTCompletionNode() {
	return action.getASTCompletionNode();
}

    public void ruleAction(int ruleNumber)
    {
        switch (ruleNumber)
        {
 
            //
            // Rule 1:  <openscope> ::= $Empty
            //
            case 1: { action.beforeConsume(); action.   openASTScope();            break;
            }
 
            //
            // Rule 12:  constant ::= integer
            //
            case 12: { action.beforeConsume(); action.   consumeExpressionConstant(IASTLiteralExpression.lk_integer_constant);            break;
            }
 
            //
            // Rule 13:  constant ::= floating
            //
            case 13: { action.beforeConsume(); action.   consumeExpressionConstant(IASTLiteralExpression.lk_float_constant);              break;
            }
 
            //
            // Rule 14:  constant ::= charconst
            //
            case 14: { action.beforeConsume(); action.   consumeExpressionConstant(IASTLiteralExpression.lk_char_constant);               break;
            }
 
            //
            // Rule 15:  constant ::= stringlit
            //
            case 15: { action.beforeConsume(); action.   consumeExpressionConstant(IASTLiteralExpression.lk_string_literal);              break;
            }
 
            //
            // Rule 17:  primary_expression ::= ident
            //
            case 17: { action.beforeConsume(); action.   consumeExpressionID();            break;
            }
 
            //
            // Rule 18:  primary_expression ::= ( expression )
            //
            case 18: { action.beforeConsume(); action.   consumeExpressionBracketed();            break;
            }
 
            //
            // Rule 20:  postfix_expression ::= postfix_expression [ expression ]
            //
            case 20: { action.beforeConsume(); action.   consumeExpressionArraySubscript();            break;
            }
 
            //
            // Rule 21:  postfix_expression ::= postfix_expression ( )
            //
            case 21: { action.beforeConsume(); action.   consumeExpressionFunctionCall(false);            break;
            }
 
            //
            // Rule 22:  postfix_expression ::= postfix_expression ( argument_expression_list )
            //
            case 22: { action.beforeConsume(); action.   consumeExpressionFunctionCall(true);            break;
            }
 
            //
            // Rule 23:  postfix_expression ::= postfix_expression . ident
            //
            case 23: { action.beforeConsume(); action.   consumeExpressionFieldReference(false);            break;
            }
 
            //
            // Rule 24:  postfix_expression ::= postfix_expression -> ident
            //
            case 24: { action.beforeConsume(); action.   consumeExpressionFieldReference(true);            break;
            }
 
            //
            // Rule 25:  postfix_expression ::= postfix_expression ++
            //
            case 25: { action.beforeConsume(); action.   consumeExpressionUnaryOperator(IASTUnaryExpression.op_postFixIncr);            break;
            }
 
            //
            // Rule 26:  postfix_expression ::= postfix_expression --
            //
            case 26: { action.beforeConsume(); action.   consumeExpressionUnaryOperator(IASTUnaryExpression.op_postFixDecr);            break;
            }
 
            //
            // Rule 27:  postfix_expression ::= ( type_name ) { <openscope> initializer_list }
            //
            case 27: { action.beforeConsume(); action.   consumeExpressionTypeIdInitializer();            break;
            }
 
            //
            // Rule 28:  postfix_expression ::= ( type_name ) { <openscope> initializer_list , }
            //
            case 28: { action.beforeConsume(); action.   consumeExpressionTypeIdInitializer();            break;
            }
 
            //
            // Rule 29:  argument_expression_list ::= assignment_expression
            //
            case 29: { action.beforeConsume(); action.   consumeExpressionArgumentExpressionList(true);            break;
            }
 
            //
            // Rule 30:  argument_expression_list ::= argument_expression_list , assignment_expression
            //
            case 30: { action.beforeConsume(); action.   consumeExpressionArgumentExpressionList(false);           break;
            }
 
            //
            // Rule 32:  unary_expression ::= ++ unary_expression
            //
            case 32: { action.beforeConsume(); action.   consumeExpressionUnaryOperator(IASTUnaryExpression.op_prefixIncr);            break;
            }
 
            //
            // Rule 33:  unary_expression ::= -- unary_expression
            //
            case 33: { action.beforeConsume(); action.   consumeExpressionUnaryOperator(IASTUnaryExpression.op_prefixDecr);            break;
            }
 
            //
            // Rule 34:  unary_expression ::= & cast_expression
            //
            case 34: { action.beforeConsume(); action.   consumeExpressionUnaryOperator(IASTUnaryExpression.op_amper);            break;
            }
 
            //
            // Rule 35:  unary_expression ::= * cast_expression
            //
            case 35: { action.beforeConsume(); action.   consumeExpressionUnaryOperator(IASTUnaryExpression.op_star);             break;
            }
 
            //
            // Rule 36:  unary_expression ::= + cast_expression
            //
            case 36: { action.beforeConsume(); action.   consumeExpressionUnaryOperator(IASTUnaryExpression.op_plus);             break;
            }
 
            //
            // Rule 37:  unary_expression ::= - cast_expression
            //
            case 37: { action.beforeConsume(); action.   consumeExpressionUnaryOperator(IASTUnaryExpression.op_minus);            break;
            }
 
            //
            // Rule 38:  unary_expression ::= ~ cast_expression
            //
            case 38: { action.beforeConsume(); action.   consumeExpressionUnaryOperator(IASTUnaryExpression.op_tilde);            break;
            }
 
            //
            // Rule 39:  unary_expression ::= ! cast_expression
            //
            case 39: { action.beforeConsume(); action.   consumeExpressionUnaryOperator(IASTUnaryExpression.op_not);              break;
            }
 
            //
            // Rule 40:  unary_expression ::= sizeof unary_expression
            //
            case 40: { action.beforeConsume(); action.   consumeExpressionUnaryOperator(IASTUnaryExpression.op_sizeof);           break;
            }
 
            //
            // Rule 41:  unary_expression ::= sizeof ( type_name )
            //
            case 41: { action.beforeConsume(); action.   consumeExpressionUnarySizeofTypeName();            break;
            }
 
            //
            // Rule 43:  cast_expression ::= ( type_name ) cast_expression
            //
            case 43: { action.beforeConsume(); action.   consumeExpressionCast();            break;
            }
 
            //
            // Rule 45:  multiplicative_expression ::= multiplicative_expression * cast_expression
            //
            case 45: { action.beforeConsume(); action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_multiply);           break;
            }
 
            //
            // Rule 46:  multiplicative_expression ::= multiplicative_expression / cast_expression
            //
            case 46: { action.beforeConsume(); action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_divide);             break;
            }
 
            //
            // Rule 47:  multiplicative_expression ::= multiplicative_expression % cast_expression
            //
            case 47: { action.beforeConsume(); action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_modulo);             break;
            }
 
            //
            // Rule 49:  additive_expression ::= additive_expression + multiplicative_expression
            //
            case 49: { action.beforeConsume(); action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_plus);            break;
            }
 
            //
            // Rule 50:  additive_expression ::= additive_expression - multiplicative_expression
            //
            case 50: { action.beforeConsume(); action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_minus);           break;
            }
 
            //
            // Rule 52:  shift_expression ::= shift_expression << additive_expression
            //
            case 52: { action.beforeConsume(); action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_shiftLeft);             break;
            }
 
            //
            // Rule 53:  shift_expression ::= shift_expression >> additive_expression
            //
            case 53: { action.beforeConsume(); action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_shiftRight);            break;
            }
 
            //
            // Rule 55:  relational_expression ::= relational_expression < shift_expression
            //
            case 55: { action.beforeConsume(); action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_lessThan);               break;
            }
 
            //
            // Rule 56:  relational_expression ::= relational_expression > shift_expression
            //
            case 56: { action.beforeConsume(); action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_greaterThan);            break;
            }
 
            //
            // Rule 57:  relational_expression ::= relational_expression <= shift_expression
            //
            case 57: { action.beforeConsume(); action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_lessEqual);              break;
            }
 
            //
            // Rule 58:  relational_expression ::= relational_expression >= shift_expression
            //
            case 58: { action.beforeConsume(); action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_greaterEqual);           break;
            }
 
            //
            // Rule 60:  equality_expression ::= equality_expression == relational_expression
            //
            case 60: { action.beforeConsume(); action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_equals);            break;
            }
 
            //
            // Rule 61:  equality_expression ::= equality_expression != relational_expression
            //
            case 61: { action.beforeConsume(); action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_notequals);            break;
            }
 
            //
            // Rule 63:  AND_expression ::= AND_expression & equality_expression
            //
            case 63: { action.beforeConsume(); action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_binaryAnd);            break;
            }
 
            //
            // Rule 65:  exclusive_OR_expression ::= exclusive_OR_expression ^ AND_expression
            //
            case 65: { action.beforeConsume(); action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_binaryXor);            break;
            }
 
            //
            // Rule 67:  inclusive_OR_expression ::= inclusive_OR_expression | exclusive_OR_expression
            //
            case 67: { action.beforeConsume(); action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_binaryOr);            break;
            }
 
            //
            // Rule 69:  logical_AND_expression ::= logical_AND_expression && inclusive_OR_expression
            //
            case 69: { action.beforeConsume(); action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_logicalAnd);            break;
            }
 
            //
            // Rule 71:  logical_OR_expression ::= logical_OR_expression || logical_AND_expression
            //
            case 71: { action.beforeConsume(); action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_logicalOr);            break;
            }
 
            //
            // Rule 73:  conditional_expression ::= logical_OR_expression ? expression : conditional_expression
            //
            case 73: { action.beforeConsume(); action.   consumeExpressionConditional();            break;
            }
 
            //
            // Rule 75:  assignment_expression ::= unary_expression = assignment_expression
            //
            case 75: { action.beforeConsume(); action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_assign);            break;
            }
 
            //
            // Rule 76:  assignment_expression ::= unary_expression *= assignment_expression
            //
            case 76: { action.beforeConsume(); action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_multiplyAssign);            break;
            }
 
            //
            // Rule 77:  assignment_expression ::= unary_expression /= assignment_expression
            //
            case 77: { action.beforeConsume(); action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_divideAssign);            break;
            }
 
            //
            // Rule 78:  assignment_expression ::= unary_expression %= assignment_expression
            //
            case 78: { action.beforeConsume(); action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_moduloAssign);            break;
            }
 
            //
            // Rule 79:  assignment_expression ::= unary_expression += assignment_expression
            //
            case 79: { action.beforeConsume(); action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_plusAssign);            break;
            }
 
            //
            // Rule 80:  assignment_expression ::= unary_expression -= assignment_expression
            //
            case 80: { action.beforeConsume(); action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_minusAssign);            break;
            }
 
            //
            // Rule 81:  assignment_expression ::= unary_expression <<= assignment_expression
            //
            case 81: { action.beforeConsume(); action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_shiftLeftAssign);            break;
            }
 
            //
            // Rule 82:  assignment_expression ::= unary_expression >>= assignment_expression
            //
            case 82: { action.beforeConsume(); action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_shiftRightAssign);            break;
            }
 
            //
            // Rule 83:  assignment_expression ::= unary_expression &= assignment_expression
            //
            case 83: { action.beforeConsume(); action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_binaryAndAssign);            break;
            }
 
            //
            // Rule 84:  assignment_expression ::= unary_expression ^= assignment_expression
            //
            case 84: { action.beforeConsume(); action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_binaryXorAssign);            break;
            }
 
            //
            // Rule 85:  assignment_expression ::= unary_expression |= assignment_expression
            //
            case 85: { action.beforeConsume(); action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_binaryOrAssign);            break;
            }
 
            //
            // Rule 86:  expression_in_statement ::= expression_list
            //
            case 86: { action.beforeConsume(); action.   consumeExpression();            break;
            }
 
            //
            // Rule 87:  expression ::= expression_list
            //
            case 87: { action.beforeConsume(); action.   consumeExpression();            break;
            }
 
            //
            // Rule 88:  expression_list ::= assignment_expression
            //
            case 88: { action.beforeConsume(); action.   consumeExpressionList(true);            break;
            }
 
            //
            // Rule 89:  expression_list ::= expression_list , assignment_expression
            //
            case 89: { action.beforeConsume(); action.   consumeExpressionList(false);            break;
            }
 
            //
            // Rule 93:  statement ::= ERROR_TOKEN
            //
            case 93: { action.beforeConsume(); action.   consumeStatementProblem();            break;
            }
 
            //
            // Rule 94:  labeled_statement ::= label_identifier : unmatched_statement
            //
            case 94: { action.beforeConsume(); action.   consumeStatementLabeled();            break;
            }
 
            //
            // Rule 95:  labeled_statement ::= case constant_expression : unmatched_statement
            //
            case 95: { action.beforeConsume(); action.   consumeStatementCase();            break;
            }
 
            //
            // Rule 96:  labeled_statement ::= default : unmatched_statement
            //
            case 96: { action.beforeConsume(); action.   consumeStatementDefault();            break;
            }
 
            //
            // Rule 97:  labeled_statement_matched ::= label_identifier : matched_statement
            //
            case 97: { action.beforeConsume(); action.   consumeStatementLabeled();            break;
            }
 
            //
            // Rule 98:  labeled_statement_matched ::= case constant_expression : matched_statement
            //
            case 98: { action.beforeConsume(); action.   consumeStatementCase();            break;
            }
 
            //
            // Rule 99:  labeled_statement_matched ::= default : matched_statement
            //
            case 99: { action.beforeConsume(); action.   consumeStatementDefault();            break;
            }
 
            //
            // Rule 100:  label_identifier ::= identifier
            //
            case 100: { action.beforeConsume(); action.   consumeName();            break;
            }
 
            //
            // Rule 101:  compound_statement ::= { }
            //
            case 101: { action.beforeConsume(); action.   consumeStatementEmptyCompoundStatement();            break;
            }
 
            //
            // Rule 102:  compound_statement ::= <openscope> { block_item_list }
            //
            case 102: { action.beforeConsume(); action.   consumeStatementCompoundStatement();            break;
            }
 
            //
            // Rule 105:  expression_statement ::= ;
            //
            case 105: { action.beforeConsume(); action.   consumeStatementNull();            break;
            }
 
            //
            // Rule 106:  expression_statement ::= expression_in_statement ;
            //
            case 106: { action.beforeConsume(); action.   consumeStatementExpression();            break;
            }
 
            //
            // Rule 108:  block_item ::= declaration
            //
            case 108: { action.beforeConsume(); action.   consumeStatementDeclaration();            break;
            }
 
            //
            // Rule 109:  switch_statement ::= switch ( expression ) unmatched_statement
            //
            case 109: { action.beforeConsume(); action.   consumeStatementSwitch();            break;
            }
 
            //
            // Rule 110:  switch_statement_matched ::= switch ( expression ) matched_statement
            //
            case 110: { action.beforeConsume(); action.   consumeStatementSwitch();            break;
            }
 
            //
            // Rule 111:  unmatched_statement ::= if ( expression ) statement
            //
            case 111: { action.beforeConsume(); action.   consumeStatementIfThen();            break;
            }
 
            //
            // Rule 112:  unmatched_statement ::= if ( expression ) matched_statement else unmatched_statement
            //
            case 112: { action.beforeConsume(); action.   consumeStatementIfThenElse();            break;
            }
 
            //
            // Rule 116:  matched_statement ::= if ( expression ) matched_statement else matched_statement
            //
            case 116: { action.beforeConsume(); action.   consumeStatementIfThenElse();            break;
            }
 
            //
            // Rule 123:  iteration_statement ::= while ( expression ) unmatched_statement
            //
            case 123: { action.beforeConsume(); action.   consumeStatementWhileLoop();            break;
            }
 
            //
            // Rule 124:  iteration_statement ::= for ( expression ; expression ; expression ) unmatched_statement
            //
            case 124: { action.beforeConsume(); action.   consumeStatementForLoop(true, true, true);            break;
            }
 
            //
            // Rule 125:  iteration_statement ::= for ( expression ; expression ; ) unmatched_statement
            //
            case 125: { action.beforeConsume(); action.   consumeStatementForLoop(true, true, false);            break;
            }
 
            //
            // Rule 126:  iteration_statement ::= for ( expression ; ; expression ) unmatched_statement
            //
            case 126: { action.beforeConsume(); action.   consumeStatementForLoop(true, false, true);            break;
            }
 
            //
            // Rule 127:  iteration_statement ::= for ( expression ; ; ) unmatched_statement
            //
            case 127: { action.beforeConsume(); action.   consumeStatementForLoop(true, false, false);            break;
            }
 
            //
            // Rule 128:  iteration_statement ::= for ( ; expression ; expression ) unmatched_statement
            //
            case 128: { action.beforeConsume(); action.   consumeStatementForLoop(false, true, true);            break;
            }
 
            //
            // Rule 129:  iteration_statement ::= for ( ; expression ; ) unmatched_statement
            //
            case 129: { action.beforeConsume(); action.   consumeStatementForLoop(false, true, false);            break;
            }
 
            //
            // Rule 130:  iteration_statement ::= for ( ; ; expression ) unmatched_statement
            //
            case 130: { action.beforeConsume(); action.   consumeStatementForLoop(false, false, true);            break;
            }
 
            //
            // Rule 131:  iteration_statement ::= for ( ; ; ) unmatched_statement
            //
            case 131: { action.beforeConsume(); action.   consumeStatementForLoop(false, false, false);            break;
            }
 
            //
            // Rule 132:  iteration_statement ::= for ( declaration expression ; expression ) unmatched_statement
            //
            case 132: { action.beforeConsume(); action.   consumeStatementForLoop(true, true, true);            break;
            }
 
            //
            // Rule 133:  iteration_statement ::= for ( declaration expression ; ) unmatched_statement
            //
            case 133: { action.beforeConsume(); action.   consumeStatementForLoop(true, true, false);            break;
            }
 
            //
            // Rule 134:  iteration_statement ::= for ( declaration ; expression ) unmatched_statement
            //
            case 134: { action.beforeConsume(); action.   consumeStatementForLoop(true, false, true);            break;
            }
 
            //
            // Rule 135:  iteration_statement ::= for ( declaration ; ) unmatched_statement
            //
            case 135: { action.beforeConsume(); action.   consumeStatementForLoop(true, false, false);            break;
            }
 
            //
            // Rule 136:  iteration_statement_matched ::= do statement while ( expression ) ;
            //
            case 136: { action.beforeConsume(); action.   consumeStatementDoLoop();            break;
            }
 
            //
            // Rule 137:  iteration_statement_matched ::= while ( expression ) matched_statement
            //
            case 137: { action.beforeConsume(); action.   consumeStatementWhileLoop();            break;
            }
 
            //
            // Rule 138:  iteration_statement_matched ::= for ( expression ; expression ; expression ) matched_statement
            //
            case 138: { action.beforeConsume(); action.   consumeStatementForLoop(true, true, true);            break;
            }
 
            //
            // Rule 139:  iteration_statement_matched ::= for ( expression ; expression ; ) matched_statement
            //
            case 139: { action.beforeConsume(); action.   consumeStatementForLoop(true, true, false);            break;
            }
 
            //
            // Rule 140:  iteration_statement_matched ::= for ( expression ; ; expression ) matched_statement
            //
            case 140: { action.beforeConsume(); action.   consumeStatementForLoop(true, false, true);            break;
            }
 
            //
            // Rule 141:  iteration_statement_matched ::= for ( expression ; ; ) matched_statement
            //
            case 141: { action.beforeConsume(); action.   consumeStatementForLoop(true, false, false);            break;
            }
 
            //
            // Rule 142:  iteration_statement_matched ::= for ( ; expression ; expression ) matched_statement
            //
            case 142: { action.beforeConsume(); action.   consumeStatementForLoop(false, true, true);            break;
            }
 
            //
            // Rule 143:  iteration_statement_matched ::= for ( ; expression ; ) matched_statement
            //
            case 143: { action.beforeConsume(); action.   consumeStatementForLoop(false, true, false);            break;
            }
 
            //
            // Rule 144:  iteration_statement_matched ::= for ( ; ; expression ) matched_statement
            //
            case 144: { action.beforeConsume(); action.   consumeStatementForLoop(false, false, true);            break;
            }
 
            //
            // Rule 145:  iteration_statement_matched ::= for ( ; ; ) matched_statement
            //
            case 145: { action.beforeConsume(); action.   consumeStatementForLoop(false, false, false);            break;
            }
 
            //
            // Rule 146:  iteration_statement_matched ::= for ( declaration expression ; expression ) matched_statement
            //
            case 146: { action.beforeConsume(); action.   consumeStatementForLoop(true, true, true);            break;
            }
 
            //
            // Rule 147:  iteration_statement_matched ::= for ( declaration expression ; ) matched_statement
            //
            case 147: { action.beforeConsume(); action.   consumeStatementForLoop(true, true, false);            break;
            }
 
            //
            // Rule 148:  iteration_statement_matched ::= for ( declaration ; expression ) matched_statement
            //
            case 148: { action.beforeConsume(); action.   consumeStatementForLoop(true, false, true);            break;
            }
 
            //
            // Rule 149:  iteration_statement_matched ::= for ( declaration ; ) matched_statement
            //
            case 149: { action.beforeConsume(); action.   consumeStatementForLoop(true, false, false);            break;
            }
 
            //
            // Rule 150:  jump_statement ::= goto identifier ;
            //
            case 150: { action.beforeConsume(); action.   consumeStatementGoto();            break;
            }
 
            //
            // Rule 151:  jump_statement ::= continue ;
            //
            case 151: { action.beforeConsume(); action.   consumeStatementContinue();            break;
            }
 
            //
            // Rule 152:  jump_statement ::= break ;
            //
            case 152: { action.beforeConsume(); action.   consumeStatementBreak();            break;
            }
 
            //
            // Rule 153:  jump_statement ::= return ;
            //
            case 153: { action.beforeConsume(); action.   consumeStatementReturn(false);            break;
            }
 
            //
            // Rule 154:  jump_statement ::= return expression ;
            //
            case 154: { action.beforeConsume(); action.   consumeStatementReturn(true);            break;
            }
 
            //
            // Rule 155:  declaration ::= declaration_specifiers ;
            //
            case 155: { action.beforeConsume(); action.   consumeDeclaration(false);            break;
            }
 
            //
            // Rule 156:  declaration ::= declaration_specifiers <openscope> init_declarator_list ;
            //
            case 156: { action.beforeConsume(); action.   consumeDeclaration(true);            break;
            }
 
            //
            // Rule 157:  declaration_specifiers ::= <openscope> simple_declaration_specifiers
            //
            case 157: { action.beforeConsume(); action.   consumeDeclarationSpecifiersSimple();           break;
            }
 
            //
            // Rule 158:  declaration_specifiers ::= <openscope> struct_or_union_declaration_specifiers
            //
            case 158: { action.beforeConsume(); action.   consumeDeclarationSpecifiersStructUnionEnum();           break;
            }
 
            //
            // Rule 159:  declaration_specifiers ::= <openscope> enum_declaration_specifiers
            //
            case 159: { action.beforeConsume(); action.   consumeDeclarationSpecifiersStructUnionEnum();           break;
            }
 
            //
            // Rule 160:  declaration_specifiers ::= <openscope> typdef_name_declaration_specifiers
            //
            case 160: { action.beforeConsume(); action.   consumeDeclarationSpecifiersTypedefName();           break;
            }
 
            //
            // Rule 187:  init_declarator ::= declarator = initializer
            //
            case 187: { action.beforeConsume(); action.   consumeDeclaratorWithInitializer();            break;
            }
 
            //
            // Rule 188:  storage_class_specifier ::= typedef
            //
            case 188: { action.beforeConsume(); action.   consumeToken();            break;
            }
 
            //
            // Rule 189:  storage_class_specifier ::= extern
            //
            case 189: { action.beforeConsume(); action.   consumeToken();            break;
            }
 
            //
            // Rule 190:  storage_class_specifier ::= static
            //
            case 190: { action.beforeConsume(); action.   consumeToken();            break;
            }
 
            //
            // Rule 191:  storage_class_specifier ::= auto
            //
            case 191: { action.beforeConsume(); action.   consumeToken();            break;
            }
 
            //
            // Rule 192:  storage_class_specifier ::= register
            //
            case 192: { action.beforeConsume(); action.   consumeToken();            break;
            }
 
            //
            // Rule 193:  type_specifier ::= void
            //
            case 193: { action.beforeConsume(); action.   consumeToken();            break;
            }
 
            //
            // Rule 194:  type_specifier ::= char
            //
            case 194: { action.beforeConsume(); action.   consumeToken();            break;
            }
 
            //
            // Rule 195:  type_specifier ::= short
            //
            case 195: { action.beforeConsume(); action.   consumeToken();            break;
            }
 
            //
            // Rule 196:  type_specifier ::= int
            //
            case 196: { action.beforeConsume(); action.   consumeToken();            break;
            }
 
            //
            // Rule 197:  type_specifier ::= long
            //
            case 197: { action.beforeConsume(); action.   consumeToken();            break;
            }
 
            //
            // Rule 198:  type_specifier ::= float
            //
            case 198: { action.beforeConsume(); action.   consumeToken();            break;
            }
 
            //
            // Rule 199:  type_specifier ::= double
            //
            case 199: { action.beforeConsume(); action.   consumeToken();            break;
            }
 
            //
            // Rule 200:  type_specifier ::= signed
            //
            case 200: { action.beforeConsume(); action.   consumeToken();            break;
            }
 
            //
            // Rule 201:  type_specifier ::= unsigned
            //
            case 201: { action.beforeConsume(); action.   consumeToken();            break;
            }
 
            //
            // Rule 202:  type_specifier ::= _Bool
            //
            case 202: { action.beforeConsume(); action.   consumeToken();            break;
            }
 
            //
            // Rule 203:  type_specifier ::= _Complex
            //
            case 203: { action.beforeConsume(); action.   consumeToken();            break;
            }
 
            //
            // Rule 204:  type_specifier ::= _Imaginary
            //
            case 204: { action.beforeConsume(); action.   consumeToken();            break;
            }
 
            //
            // Rule 205:  typedef_name ::= ident
            //
            case 205: { action.beforeConsume(); action.   consumeToken();            break;
            }
 
            //
            // Rule 206:  struct_or_union_specifier ::= struct { <openscope> struct_declaration_list_opt }
            //
            case 206: { action.beforeConsume(); action.   consumeTypeSpecifierComposite(false, IASTCompositeTypeSpecifier.k_struct);            break;
            }
 
            //
            // Rule 207:  struct_or_union_specifier ::= union { <openscope> struct_declaration_list_opt }
            //
            case 207: { action.beforeConsume(); action.   consumeTypeSpecifierComposite(false, IASTCompositeTypeSpecifier.k_union);            break;
            }
 
            //
            // Rule 208:  struct_or_union_specifier ::= struct struct_or_union_identifier { <openscope> struct_declaration_list_opt }
            //
            case 208: { action.beforeConsume(); action.   consumeTypeSpecifierComposite(true, IASTCompositeTypeSpecifier.k_struct);            break;
            }
 
            //
            // Rule 209:  struct_or_union_specifier ::= union struct_or_union_identifier { <openscope> struct_declaration_list_opt }
            //
            case 209: { action.beforeConsume(); action.   consumeTypeSpecifierComposite(true, IASTCompositeTypeSpecifier.k_union);            break;
            }
 
            //
            // Rule 210:  struct_or_union_specifier ::= struct struct_or_union_identifier
            //
            case 210: { action.beforeConsume(); action.   consumeTypeSpecifierElaborated(IASTElaboratedTypeSpecifier.k_struct);            break;
            }
 
            //
            // Rule 211:  struct_or_union_specifier ::= union struct_or_union_identifier
            //
            case 211: { action.beforeConsume(); action.   consumeTypeSpecifierElaborated(IASTElaboratedTypeSpecifier.k_union);            break;
            }
 
            //
            // Rule 212:  struct_or_union_identifier ::= identifier
            //
            case 212: { action.beforeConsume(); action.   consumeName();            break;
            }
 
            //
            // Rule 217:  struct_declaration ::= specifier_qualifier_list <openscope> struct_declarator_list ;
            //
            case 217: { action.beforeConsume(); action.   consumeStructDeclaration(true);            break;
            }
 
            //
            // Rule 218:  struct_declaration ::= specifier_qualifier_list ;
            //
            case 218: { action.beforeConsume(); action.   consumeStructDeclaration(false);            break;
            }
 
            //
            // Rule 223:  struct_declarator ::= : constant_expression
            //
            case 223: { action.beforeConsume(); action.   consumeStructBitField(false);            break;
            }
 
            //
            // Rule 224:  struct_declarator ::= declarator : constant_expression
            //
            case 224: { action.beforeConsume(); action.   consumeStructBitField(true);             break;
            }
 
            //
            // Rule 225:  enum_identifier ::= identifier
            //
            case 225: { action.beforeConsume(); action.   consumeName();            break;
            }
 
            //
            // Rule 226:  enum_specifier ::= enum { <openscope> enumerator_list_opt }
            //
            case 226: { action.beforeConsume(); action.   consumeTypeSpecifierEnumeration(false);            break;
            }
 
            //
            // Rule 227:  enum_specifier ::= enum enum_identifier { <openscope> enumerator_list_opt }
            //
            case 227: { action.beforeConsume(); action.   consumeTypeSpecifierEnumeration(true);            break;
            }
 
            //
            // Rule 228:  enum_specifier ::= enum { <openscope> enumerator_list_opt , }
            //
            case 228: { action.beforeConsume(); action.   consumeTypeSpecifierEnumeration(false);            break;
            }
 
            //
            // Rule 229:  enum_specifier ::= enum enum_identifier { <openscope> enumerator_list_opt , }
            //
            case 229: { action.beforeConsume(); action.   consumeTypeSpecifierEnumeration(true);            break;
            }
 
            //
            // Rule 230:  enum_specifier ::= enum enum_identifier
            //
            case 230: { action.beforeConsume(); action.   consumeTypeSpecifierElaborated(IASTElaboratedTypeSpecifier.k_enum);            break;
            }
 
            //
            // Rule 235:  enumerator ::= enum_identifier
            //
            case 235: { action.beforeConsume(); action.   consumeEnumerator(false);            break;
            }
 
            //
            // Rule 236:  enumerator ::= enum_identifier = constant_expression
            //
            case 236: { action.beforeConsume(); action.   consumeEnumerator(true);            break;
            }
 
            //
            // Rule 237:  type_qualifier ::= const
            //
            case 237: { action.beforeConsume(); action.   consumeToken();            break;
            }
 
            //
            // Rule 238:  type_qualifier ::= restrict
            //
            case 238: { action.beforeConsume(); action.   consumeToken();            break;
            }
 
            //
            // Rule 239:  type_qualifier ::= volatile
            //
            case 239: { action.beforeConsume(); action.   consumeToken();            break;
            }
 
            //
            // Rule 240:  function_specifier ::= inline
            //
            case 240: { action.beforeConsume(); action.   consumeToken();            break;
            }
 
            //
            // Rule 242:  declarator ::= <openscope> pointer direct_declarator
            //
            case 242: { action.beforeConsume(); action.   consumeDeclaratorWithPointer(true);            break;
            }
 
            //
            // Rule 243:  direct_declarator ::= identifier
            //
            case 243: { action.beforeConsume(); action.   consumeDirectDeclaratorIdentifier();            break;
            }
 
            //
            // Rule 244:  direct_declarator ::= ( declarator )
            //
            case 244: { action.beforeConsume(); action.   consumeDirectDeclaratorBracketed();            break;
            }
 
            //
            // Rule 247:  array_direct_declarator ::= direct_declarator array_modifier
            //
            case 247: { action.beforeConsume(); action.   consumeDirectDeclaratorArrayDeclarator();            break;
            }
 
            //
            // Rule 248:  function_direct_declarator ::= direct_declarator ( <openscope> parameter_type_list )
            //
            case 248: { action.beforeConsume(); action.   consumeDirectDeclaratorFunctionDeclarator(true);            break;
            }
 
            //
            // Rule 249:  function_direct_declarator ::= direct_declarator ( )
            //
            case 249: { action.beforeConsume(); action.   consumeDirectDeclaratorFunctionDeclarator(false);            break;
            }
 
            //
            // Rule 251:  function_declarator ::= <openscope> pointer function_direct_declarator
            //
            case 251: { action.beforeConsume(); action.   consumeDeclaratorWithPointer(true);            break;
            }
 
            //
            // Rule 252:  knr_direct_declarator ::= direct_declarator ( <openscope> identifier_list )
            //
            case 252: { action.beforeConsume(); action.   consumeDirectDeclaratorFunctionDeclaratorKnR();            break;
            }
 
            //
            // Rule 254:  knr_function_declarator ::= <openscope> pointer knr_direct_declarator
            //
            case 254: { action.beforeConsume(); action.   consumeDeclaratorWithPointer(true);            break;
            }
 
            //
            // Rule 255:  array_modifier ::= [ ]
            //
            case 255: { action.beforeConsume(); action.   consumeDirectDeclaratorArrayModifier(false);            break;
            }
 
            //
            // Rule 256:  array_modifier ::= [ <openscope> type_qualifier_list ]
            //
            case 256: { action.beforeConsume(); action.   consumeDirectDeclaratorModifiedArrayModifier(false, false, true,  false);            break;
            }
 
            //
            // Rule 257:  array_modifier ::= [ assignment_expression ]
            //
            case 257: { action.beforeConsume(); action.   consumeDirectDeclaratorArrayModifier(true );            break;
            }
 
            //
            // Rule 258:  array_modifier ::= [ <openscope> type_qualifier_list assignment_expression ]
            //
            case 258: { action.beforeConsume(); action.   consumeDirectDeclaratorModifiedArrayModifier(false, false, true,  true );            break;
            }
 
            //
            // Rule 259:  array_modifier ::= [ static assignment_expression ]
            //
            case 259: { action.beforeConsume(); action.   consumeDirectDeclaratorModifiedArrayModifier(true,  false, false, true );            break;
            }
 
            //
            // Rule 260:  array_modifier ::= [ static <openscope> type_qualifier_list assignment_expression ]
            //
            case 260: { action.beforeConsume(); action.   consumeDirectDeclaratorModifiedArrayModifier(true,  false, true,  true );            break;
            }
 
            //
            // Rule 261:  array_modifier ::= [ <openscope> type_qualifier_list static assignment_expression ]
            //
            case 261: { action.beforeConsume(); action.   consumeDirectDeclaratorModifiedArrayModifier(true,  false, true,  true );            break;
            }
 
            //
            // Rule 262:  array_modifier ::= [ * ]
            //
            case 262: { action.beforeConsume(); action.   consumeDirectDeclaratorModifiedArrayModifier(false, true,  false, false);            break;
            }
 
            //
            // Rule 263:  array_modifier ::= [ <openscope> type_qualifier_list * ]
            //
            case 263: { action.beforeConsume(); action.   consumeDirectDeclaratorModifiedArrayModifier(false, true,  true,  false);            break;
            }
 
            //
            // Rule 264:  pointer ::= *
            //
            case 264: { action.beforeConsume(); action.   consumePointer();            break;
            }
 
            //
            // Rule 265:  pointer ::= pointer *
            //
            case 265: { action.beforeConsume(); action.   consumePointer();            break;
            }
 
            //
            // Rule 266:  pointer ::= * <openscope> type_qualifier_list
            //
            case 266: { action.beforeConsume(); action.   consumePointerTypeQualifierList();            break;
            }
 
            //
            // Rule 267:  pointer ::= pointer * <openscope> type_qualifier_list
            //
            case 267: { action.beforeConsume(); action.   consumePointerTypeQualifierList();            break;
            }
 
            //
            // Rule 275:  parameter_declaration ::= declaration_specifiers init_declarator
            //
            case 275: { action.beforeConsume(); action.   consumeParameterDeclaration(true);            break;
            }
 
            //
            // Rule 276:  parameter_declaration ::= declaration_specifiers
            //
            case 276: { action.beforeConsume(); action.   consumeParameterDeclaration(false);           break;
            }
 
            //
            // Rule 277:  parameter_declaration ::= declaration_specifiers abstract_declarator
            //
            case 277: { action.beforeConsume(); action.   consumeParameterDeclaration(true);            break;
            }
 
            //
            // Rule 278:  identifier_list ::= identifier
            //
            case 278: { action.beforeConsume(); action.   consumeName();            break;
            }
 
            //
            // Rule 279:  identifier_list ::= identifier_list , identifier
            //
            case 279: { action.beforeConsume(); action.   consumeName();            break;
            }
 
            //
            // Rule 280:  type_name ::= specifier_qualifier_list
            //
            case 280: { action.beforeConsume(); action.   consumeTypeId(false);            break;
            }
 
            //
            // Rule 281:  type_name ::= specifier_qualifier_list abstract_declarator
            //
            case 281: { action.beforeConsume(); action.   consumeTypeId(true);            break;
            }
 
            //
            // Rule 282:  abstract_declarator ::= <openscope> pointer
            //
            case 282: { action.beforeConsume(); action.   consumeDeclaratorWithPointer(false);            break;
            }
 
            //
            // Rule 284:  abstract_declarator ::= <openscope> pointer direct_abstract_declarator
            //
            case 284: { action.beforeConsume(); action.   consumeDeclaratorWithPointer(true);             break;
            }
 
            //
            // Rule 285:  direct_abstract_declarator ::= ( abstract_declarator )
            //
            case 285: { action.beforeConsume(); action.   consumeDirectDeclaratorBracketed();            break;
            }
 
            //
            // Rule 286:  direct_abstract_declarator ::= array_modifier
            //
            case 286: { action.beforeConsume(); action.   consumeAbstractDeclaratorArrayModifier(false);            break;
            }
 
            //
            // Rule 287:  direct_abstract_declarator ::= direct_abstract_declarator array_modifier
            //
            case 287: { action.beforeConsume(); action.   consumeAbstractDeclaratorArrayModifier(true);             break;
            }
 
            //
            // Rule 288:  direct_abstract_declarator ::= ( )
            //
            case 288: { action.beforeConsume(); action.   consumeAbstractDeclaratorFunctionDeclarator(false, false);           break;
            }
 
            //
            // Rule 289:  direct_abstract_declarator ::= direct_abstract_declarator ( )
            //
            case 289: { action.beforeConsume(); action.   consumeAbstractDeclaratorFunctionDeclarator(true, false);            break;
            }
 
            //
            // Rule 290:  direct_abstract_declarator ::= ( <openscope> parameter_type_list )
            //
            case 290: { action.beforeConsume(); action.   consumeAbstractDeclaratorFunctionDeclarator(false, true);            break;
            }
 
            //
            // Rule 291:  direct_abstract_declarator ::= direct_abstract_declarator ( <openscope> parameter_type_list )
            //
            case 291: { action.beforeConsume(); action.   consumeAbstractDeclaratorFunctionDeclarator(true, true);             break;
            }
 
            //
            // Rule 292:  initializer ::= assignment_expression
            //
            case 292: { action.beforeConsume(); action.   consumeInitializer();            break;
            }
 
            //
            // Rule 293:  initializer ::= { <openscope> initializer_list }
            //
            case 293: { action.beforeConsume(); action.   consumeInitializerList();            break;
            }
 
            //
            // Rule 294:  initializer ::= { <openscope> initializer_list , }
            //
            case 294: { action.beforeConsume(); action.   consumeInitializerList();            break;
            }
 
            //
            // Rule 299:  designated_initializer ::= <openscope> designation initializer
            //
            case 299: { action.beforeConsume(); action.   consumeInitializerDesignated();            break;
            }
 
            //
            // Rule 303:  designator ::= [ constant_expression ]
            //
            case 303: { action.beforeConsume(); action.   consumeDesignatorArrayDesignator();            break;
            }
 
            //
            // Rule 304:  designator ::= . identifier
            //
            case 304: { action.beforeConsume(); action.   consumeDesignatorFieldDesignator();            break;
            }
 
            //
            // Rule 305:  translation_unit ::= external_declaration_list
            //
            case 305: { action.beforeConsume(); action.   consumeTranslationUnit();            break;
            }
 
            //
            // Rule 306:  translation_unit ::= $Empty
            //
            case 306: { action.beforeConsume(); action.   consumeTranslationUnit();            break;
            }
 
            //
            // Rule 311:  external_declaration ::= ;
            //
            case 311: { action.beforeConsume(); action.   consumeDeclarationEmpty();           break;
            }
 
            //
            // Rule 312:  external_declaration ::= ERROR_TOKEN
            //
            case 312: { action.beforeConsume(); action.   consumeDeclarationProblem();            break;
            }
 
            //
            // Rule 313:  function_definition ::= declaration_specifiers <openscope> function_declarator compound_statement
            //
            case 313: { action.beforeConsume(); action.   consumeFunctionDefinition();            break;
            }
 
            //
            // Rule 314:  function_definition ::= declaration_specifiers <openscope> knr_function_declarator <openscope> declaration_list compound_statement
            //
            case 314: { action.beforeConsume(); action.   consumeFunctionDefinitionKnR();            break;
            }

    
            default:
                break;
        }
        return;
    }
}

